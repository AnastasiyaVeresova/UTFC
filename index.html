<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.plot.ly https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; img-src 'self' data:;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style_menu_main.css">
    <link rel="stylesheet" href="css/card.css">
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="script/products_lists/allProducts.js"></script>
    <title>Каталог</title>

</head>

<body>
    <!-- Боковое меню -->
    <div class="sidebar">
        <!-- Фильтр по категории -->
        <h3 class="filter-header">
            Категория
            <button class="toggle-filter" data-target="category-filter-content">−</button>
        </h3>
        <div class="filter-content expanded" id="category-filter-content" style="max-height: 500px;">
            <div class="checkbox-group">
                <label><input type="checkbox" class="category-filter" value="armchair_rukovoditel" checked> Кресла для
                    руководителя</label>
                <label><input type="checkbox" class="category-filter" value="armchair_personal" checked> Кресла для
                    персонала</label>
                <label><input type="checkbox" class="category-filter" value="armchair_comfort" checked> Кресла
                    комфорт</label>
                <label><input type="checkbox" class="category-filter" value="chair_cafe_and_bar" checked> Стулья для
                    кафе и бара</label>
                <label><input type="checkbox" class="category-filter" value="chair_visitors" checked> Стулья для
                    посетителей</label>
                <label><input type="checkbox" class="category-filter" value="armchair_epik" checked> Кресла EPIK</label>
            </div>
        </div>

        <!-- Фильтр по наличию индикаторов -->
        <h3 class="filter-header">
            Спец. предложения
            <button class="toggle-filter" data-target="special-offers-filter-content">−</button>
        </h3>
        <div class="filter-content expanded" id="special-offers-filter-content" style="max-height: 200px;">
            <div class="checkbox-group">
                <label><input type="checkbox" class="special-offer-filter" value="clean"> Распродажа остатков</label>
                <label><input type="checkbox" class="special-offer-filter" value="limit"> Минимальный заказ</label>
            </div>
        </div>


        <!-- Фильтр по высоте -->
        <div class="filter-block">
            <h3>Габаритная высота</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minHeight" min="400" max="1800" step="5" value="400">
                <input type="range" id="maxHeight" min="400" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minHeightValue" min="400" max="1800" step="5" value="400">
                <span>—</span>
                <input type="number" id="maxHeightValue" min="400" max="1800" step="5" value="1800">
            </div>
        </div>

        <!-- Фильтр по высоте сиденья от пола -->
        <div class="filter-block">
            <h3>Высота сиденья от пола</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minSeatToFloorHeight" min="100" max="1800" step="5" value="100">
                <input type="range" id="maxSeatToFloorHeight" min="100" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minSeatToFloorHeightValue" min="100" max="1800" step="5" value="100">
                <span>—</span>
                <input type="number" id="maxSeatToFloorHeightValue" min="100" max="1800" step="5" value="1800">
            </div>
        </div>

        <!-- Фильтр по ширине сиденья с подлокотниками -->
        <div class="filter-block">
            <h3>Габаритная ширина</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minSeatWidthWithArmrests" min="100" max="1800" step="5" value="100">
                <input type="range" id="maxSeatWidthWithArmrests" min="100" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minSeatWidthWithArmrestsValue" min="100" max="1800" step="5" value="100">
                <span>—</span>
                <input type="number" id="maxSeatWidthWithArmrestsValue" min="100" max="1800" step="5" value="1800">
            </div>
        </div>

        <!-- Фильтр по ширине сиденья -->
        <div class="filter-block">
            <h3>Ширина сиденья</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minSeatWidth" min="100" max="1800" step="5" value="100">
                <input type="range" id="maxSeatWidth" min="100" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minSeatWidthValue" min="100" max="1800" step="5" value="100">
                <span>—</span>
                <input type="number" id="maxSeatWidthValue" min="100" max="1800" step="5" value="1800">
            </div>
        </div>

        <!-- Фильтр по габаритной глубине -->
        <div class="filter-block">
            <h3>Габаритная глубина</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minChairDepth" min="100" max="1800" step="5" value="100">
                <input type="range" id="maxChairDepth" min="100" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minChairDepthValue" min="100" max="1800" step="5" value="100">
                <span>—</span>
                <input type="number" id="maxChairDepthValue" min="100" max="1800" step="5" value="1800">
            </div>
        </div>

        <!-- Фильтр по глубине сиденья -->
        <div class="filter-block">
            <h3>Глубина сиденья</h3>
            <div class="range-slider">
                <div class="range-track"></div>
                <input type="range" id="minSeatDepth" min="100" max="1800" step="5" value="100">
                <input type="range" id="maxSeatDepth" min="100" max="1800" step="5" value="1800">
            </div>
            <div class="range-values">
                <input type="number" id="minSeatDepthValue" min="100" max="1800" step="5" value="100">
                <span>—</span>
                <input type="number" id="maxSeatDepthValue" min="100" max="1800" step="5" value="1800">
            </div>
        </div>


        <!-- Блок поиска -->
        <div class="search-block">
            <div class="search-input-container">
                <input type="text" id="searchInput" placeholder="Поиск...Наведите для подсказки">
                <span class="search-icon">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                </span>
                <span class="search-tooltip">
                    <strong>Поиск</strong><br><br>
                    Увидим все карточки, в описании которых присутствуют <strong>ВСЕ</strong> введенные слова<br>
                    Можно вводить несколько значений через запятую<br>
                    Например: люкс, топ, черный<br><br>
                    <hr><br>
                    <strong>Подлокотники +<br>Конструктив +<br>Исполнение +</strong><br><br>
                    Увидим только те карточки, в наименовании которых (как в "Таблице с размерами (для внутреннего
                    пользования).xlsx") есть выбранные позиции<br><br>
                    <hr><br>
                    Есть функционал по отсутствующим значениям w+ - ширина с подлокотниками | w - ширина сиденья | d -
                    габаритная глубина | h - высота<br>
                    Просто введите, например, высота не указана или h не указана<br><br>
                    <hr><br>
                    &#10024; Если вы нашли ошибку или не видите соответствующего желаемого в выдаче, просим сообщить в
                    отдел маркетинга, поправим &#128522;
                </span>
            </div>
        </div>

        <!-- Подлокотники -->
        <h3 class="filter-header">
            Подлокотники
            <button class="toggle-filter" data-target="armrest-filter-content">+</button>
        </h3>
        <div class="filter-content" id="armrest-filter-content">
            <div class="checkbox-group">
                <label><input type="checkbox" class="armrest-filter" value="б_п|бп|Б_п"> Без подлокотников</label>
                <label><input type="checkbox" class="armrest-filter" value="рондо"> Рондо</label>
                <label><input type="checkbox" class="armrest-filter" value="гольф"> Гольф</label>
                <label><input type="checkbox" class="armrest-filter" value="нептун"> Нептун</label>
                <label><input type="checkbox" class="armrest-filter" value="самба"> Самба</label>
                <label><input type="checkbox" class="armrest-filter" value="соната"> Соната</label>
                <label><input type="checkbox" class="armrest-filter" value="t-01|t01|T-01|т-01"> T-01</label>
                <label><input type="checkbox" class="armrest-filter" value="ХДП|хдп"> ХДП</label>
            </div>
        </div>

        <!-- Конструктив -->
        <h3 class="filter-header">
            Конструктив
            <button class="toggle-filter" data-target="mechanism-filter-content">+</button>
        </h3>
        <div class="filter-content" id="mechanism-filter-content">
            <div class="checkbox-group">
                <label><input type="checkbox" class="mechanism-filter" value="пиастра"> Пиастра</label>
                <label><input type="checkbox" class="mechanism-filter" value="TG|tg|тг|топ-ган|Топ-ган"> Топ-ган</label>
                <label><input type="checkbox" class="mechanism-filter" value="GTP|gtp|Gtp|GTS|gts|Gts|ЖТС|жтс">
                    GTP/GTS</label>
                <label><input type="checkbox" class="mechanism-filter" value="мультиблок|mb|MB|Mb| мб|MB">
                    Мультиблок</label>
                <label><input type="checkbox" class="mechanism-filter" value="ПВМ|пвм"> ПВМ</label>
                <label><input type="checkbox" class="mechanism-filter" value="CPT|срт"> CPT</label>
                <label><input type="checkbox" class="mechanism-filter" value=" О | O | о | o |_о_|овалина">
                    Овалина</label>
                <label><input type="checkbox" class="mechanism-filter" value="EG|eg"> EG</label>
                <label><input type="checkbox" class="mechanism-filter" value="н_п|н-п|нп|полозья|Н_п|В_п|в_п">
                    Полозья</label>
                <label><input type="checkbox" class="mechanism-filter" value="подг|подголовник|подголовником">
                    Подголовник</label>
                <label><input type="checkbox" class="mechanism-filter" value="стол|столик|столиком"> Столик</label>
            </div>
        </div>

        <!-- Исполнение -->
        <h3 class="filter-header">
            Исполнение
            <button class="toggle-filter" data-target="finish-filter-content">+</button>
        </h3>
        <div class="filter-content" id="finish-filter-content">
            <div class="checkbox-group">
                <label><input type="checkbox" class="finish-filter" value="хром| ch| CH| Ch"> Хром</label>
                <label><input type="checkbox" class="finish-filter" value="пластик|пластик-люкс|pl|ppl"> Пластик</label>
                <label><input type="checkbox" class="finish-filter" value="дерев|дерево"> Дерево</label>
                <label><input type="checkbox" class="finish-filter" value="бел|белый|white"> Белый</label>
                <label><input type="checkbox" class="finish-filter" value="черн|черный|black|bl"> Черный</label>
                <label><input type="checkbox" class="finish-filter" value="сер|серый|grey|gray"> Серый</label>
            </div>
        </div>

        <!-- Фильтр по нагрузке -->
        <h3 class="filter-header">
            Нагрузка max
            <button class="toggle-filter" data-target="load-filter-content">+</button>
        </h3>
        <div class="filter-content" id="load-filter-content">
            <div class="checkbox-group">
                <label><input type="checkbox" class="load-filter" value="90"> 90 кг</label>
                <label><input type="checkbox" class="load-filter" value="120"> 120 кг</label>
                <label><input type="checkbox" class="load-filter" value="130"> 130 кг</label>
                <label><input type="checkbox" class="load-filter" value="150"> 150 кг</label>
                <label><input type="checkbox" class="load-filter" value="180"> 180 кг</label>
                <label><input type="checkbox" class="load-filter" value="210"> 210 кг</label>
                <label><input type="checkbox" class="load-filter" value="other"> Другие варианты</label>



            </div>
        </div>
        <!-- Фильтр по пятилучьям -->
        <h3 class="filter-header">
            Диаметр пятилучья
            <button class="toggle-filter" data-target="diameter-filter-content">+</button>
        </h3>
        <div class="filter-content" id="diameter-filter-content">
            <div class="checkbox-group">
                <label><input type="checkbox" class="diameter-filter" value="480"> 480</label>
                <label><input type="checkbox" class="diameter-filter" value="580"> 580</label>
                <label><input type="checkbox" class="diameter-filter" value="600"> 600</label>
                <label><input type="checkbox" class="diameter-filter" value="630"> 630</label>
                <label><input type="checkbox" class="diameter-filter" value="640"> 640</label>
                <label><input type="checkbox" class="diameter-filter" value="660"> 660</label>
                <label><input type="checkbox" class="diameter-filter" value="680"> 680</label>
                <label><input type="checkbox" class="diameter-filter" value="700"> 700</label>
                <label><input type="checkbox" class="diameter-filter" value="720"> 720</label>
                <label><input type="checkbox" class="diameter-filter" value="740"> 740</label>
                <label><input type="checkbox" class="diameter-filter" value="760"> 760</label>
                <label><input type="checkbox" class="diameter-filter" value="other"> Другие варианты</label>

            </div>
        </div>
    </div>



    <!-- Основной контент -->
    <div class="center">
        <div class="content">
            <h1>Каталог</h1>
            <div class="analytics-block">
                <div class="analytics-header">
                    <button class="toggle-button" id="toggleAnalytics">Скрыть общую аналитику</button>
                </div>
                <div class="analytics-content" id="analyticsContent" style="height: 660px; min-height: 660px;">
                    <div id="overallChart" style="height: 100%;"></div>
                </div>
            </div>
            <div class="products-count">Актуальное количество: <span id="productsCountValue">0</span></div>

            <div class="text_dop_info">
                w+ - ширина с подлокотниками | w - ширина сиденья | d - габаритная глубина | h - высота | <span
                    style="color: red; font-size: 14px;">●</span> — распродаём остатки | <span
                    style="color: #96C22B; font-size: 14px;">●</span> — минимальный заказ от...


            </div>
            <div id="products"></div>
        </div>
    </div>

    <script>
        let currentTooltip = null;
        let currentCard = null;
        let minHeightInput, maxHeightInput, minHeightValue, maxHeightValue;
        let minSeatWidthWithArmrestsInput, maxSeatWidthWithArmrestsInput;
        let minSeatToFloorHeightInput, maxSeatToFloorHeightInput;
        let minChairDepthInput, maxChairDepthInput, minChairDepthValue, maxChairDepthValue;
        let minSeatDepthInput, maxSeatDepthInput, minSeatDepthValue, maxSeatDepthValue;
        let minSeatWidthInput, maxSeatWidthInput, minSeatWidthValue, maxSeatWidthValue;
        let validProducts = [];
        let filteredProducts = [];
        let isSeatWidthWithArmrestsChanged = false;
        let isSeatToFloorHeightChanged = false;
        let isChairHeightChanged = false;
        let isChairDepthChanged = false;
        let isSeatDepthChanged = false;
        let isSeatWidthChanged = false;




        // Функция для обновления позиции подсказки
        function updateTooltipPosition(card, tooltip) {
            const rect = card.getBoundingClientRect();
            const tooltipWidth = 300;
            const tooltipHeight = tooltip.offsetHeight || 200;
            let left = rect.right + window.scrollX + 10;
            if (left + tooltipWidth > window.innerWidth) {
                left = rect.left + window.scrollX - tooltipWidth - 10;
            }
            let top = rect.top + window.scrollY;
            if (top + tooltipHeight > window.innerHeight) {
                top = rect.bottom + window.scrollY - tooltipHeight - 10;
            }
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }

        // Функция для парсинга чисел
        function parseNumber(value) {
            if (value === null || value === undefined || value === "") {
                return null;
            }
            const strValue = String(value).replace(',', '.');
            const numValue = parseFloat(strValue);
            return isNaN(numValue) ? null : numValue;
        }

        function recalculateSliderValues(filteredProducts = []) {
            // Используем отфильтрованные товары, если они переданы, иначе — все товары
            const productsToUse = filteredProducts.length > 0 ? filteredProducts : validProducts;

            // Получаем выбранные категории
            const selectedCategories = Array.from(document.querySelectorAll('.category-filter:checked')).map(el => el.value);
            let filteredByCategory = productsToUse;



            // Фильтруем по категории, если выбраны категории
            if (selectedCategories.length > 0) {
                filteredByCategory = productsToUse.filter(product =>
                    product.category && selectedCategories.includes(product.category)
                );
            }

            // Фильтруем по спецпредложениям, если они выбраны
            const specialOfferFilters = Array.from(document.querySelectorAll('.special-offer-filter:checked')).map(el => el.value);
            if (specialOfferFilters.length > 0) {
                filteredByCategory = filteredByCategory.filter(product => {
                    const hasClean = product.lost?.[0]?.clean === true;
                    const hasLimit = product.lost?.[0]?.limit === true;

                    // Проверяем наличие нужных индикаторов
                    if (specialOfferFilters.includes("clean") && !hasClean) {
                        return false;
                    }
                    if (specialOfferFilters.includes("limit") && !hasLimit) {
                        return false;
                    }
                    return true;
                });
            }

            // Если после фильтрации нет товаров, используем дефолтные значения
            if (filteredByCategory.length === 0) {
                filteredByCategory = productsToUse;
            }

            // Пересчитываем min/max для высоты кресла
            let minHeightPossible = Infinity;
            let maxHeightPossible = -Infinity;
            filteredByCategory.forEach(product => {
                const chairHeight = product.dimensions_details?.[0]?.chair_height;
                if (chairHeight) {
                    if (chairHeight.min && !isNaN(parseInt(chairHeight.min)) && parseInt(chairHeight.min) < minHeightPossible) {
                        minHeightPossible = parseInt(chairHeight.min);
                    }
                    if (chairHeight.max && !isNaN(parseInt(chairHeight.max)) && parseInt(chairHeight.max) > maxHeightPossible) {
                        maxHeightPossible = parseInt(chairHeight.max);
                    }
                }
            });

            // Обновляем интерфейс для высоты кресла
            if (minHeightPossible !== Infinity) {
                minHeightInput.min = minHeightPossible;
                minHeightValue.min = minHeightPossible;
                minHeightInput.value = minHeightPossible;
                minHeightValue.value = minHeightPossible;
            } else {
                minHeightInput.min = 400;
                minHeightValue.min = 400;
                minHeightInput.value = 400;
                minHeightValue.value = 400;
            }

            if (maxHeightPossible !== -Infinity) {
                maxHeightInput.max = maxHeightPossible;
                maxHeightValue.max = maxHeightPossible;
                maxHeightInput.value = maxHeightPossible;
                maxHeightValue.value = maxHeightPossible;
            } else {
                maxHeightInput.max = 1800;
                maxHeightValue.max = 1800;
                maxHeightInput.value = 1800;
                maxHeightValue.value = 1800;
            }

            // Пересчитываем min/max для ширины сиденья с подлокотниками
            let minSeatWidthWithArmrestsPossible = Infinity;
            let maxSeatWidthWithArmrestsPossible = -Infinity;
            filteredByCategory.forEach(product => {
                const dimensions = product.dimensions_details?.[0] || {};
                const seatWidthWithArmrests = dimensions.seat_width_with_armrests;
                const diameterCross = dimensions.diameter_cross;
                const runnersWidth = dimensions.runners_width;
                const seatWidth = dimensions.seat_width;
                const chairDepth = dimensions.chair_depth;

                // Проверяем все возможные поля для габаритной ширины
                const possibleWidthsMin = [
                    seatWidthWithArmrests?.min,
                    diameterCross?.min,
                    runnersWidth?.min,
                    seatWidth?.min,
                    chairDepth?.min,
                ].filter(w => w !== undefined && w !== null && !isNaN(parseInt(w)));

                const possibleWidthsMax = [
                    seatWidthWithArmrests?.max,
                    diameterCross?.max,
                    runnersWidth?.max,
                    seatWidth?.max,
                    chairDepth?.max,
                ].filter(w => w !== undefined && w !== null && !isNaN(parseInt(w)));

                if (possibleWidthsMin.length > 0) {
                    const currentMin = Math.min(...possibleWidthsMin.map(w => parseInt(w)));
                    if (currentMin < minSeatWidthWithArmrestsPossible) {
                        minSeatWidthWithArmrestsPossible = currentMin;
                    }
                }

                if (possibleWidthsMax.length > 0) {
                    const currentMax = Math.max(...possibleWidthsMax.map(w => parseInt(w)));
                    if (currentMax > maxSeatWidthWithArmrestsPossible) {
                        maxSeatWidthWithArmrestsPossible = currentMax;
                    }
                }
            });

            // Обновляем интерфейс для ширины сиденья с подлокотниками
            if (minSeatWidthWithArmrestsPossible !== Infinity) {
                minSeatWidthWithArmrestsInput.min = minSeatWidthWithArmrestsPossible;
                minSeatWidthWithArmrestsValue.min = minSeatWidthWithArmrestsPossible;
                minSeatWidthWithArmrestsInput.value = minSeatWidthWithArmrestsPossible;
                minSeatWidthWithArmrestsValue.value = minSeatWidthWithArmrestsPossible;
            } else {
                minSeatWidthWithArmrestsInput.min = 100;
                minSeatWidthWithArmrestsValue.min = 100;
                minSeatWidthWithArmrestsInput.value = 100;
                minSeatWidthWithArmrestsValue.value = 100;
            }

            if (maxSeatWidthWithArmrestsPossible !== -Infinity) {
                maxSeatWidthWithArmrestsInput.max = maxSeatWidthWithArmrestsPossible;
                maxSeatWidthWithArmrestsValue.max = maxSeatWidthWithArmrestsPossible;
                maxSeatWidthWithArmrestsInput.value = maxSeatWidthWithArmrestsPossible;
                maxSeatWidthWithArmrestsValue.value = maxSeatWidthWithArmrestsPossible;
            } else {
                maxSeatWidthWithArmrestsInput.max = 1800;
                maxSeatWidthWithArmrestsValue.max = 1800;
                maxSeatWidthWithArmrestsInput.value = 1800;
                maxSeatWidthWithArmrestsValue.value = 1800;
            }

            // Пересчитываем min/max для высоты сиденья от пола
            let minSeatToFloorHeightPossible = Infinity;
            let maxSeatToFloorHeightPossible = -Infinity;
            filteredByCategory.forEach(product => {
                const seatToFloorHeight = product.dimensions_details?.[0]?.seat_to_floor_height;
                if (seatToFloorHeight) {
                    if (seatToFloorHeight.min && !isNaN(parseInt(seatToFloorHeight.min)) && parseInt(seatToFloorHeight.min) < minSeatToFloorHeightPossible) {
                        minSeatToFloorHeightPossible = parseInt(seatToFloorHeight.min);
                    }
                    if (seatToFloorHeight.max && !isNaN(parseInt(seatToFloorHeight.max)) && parseInt(seatToFloorHeight.max) > maxSeatToFloorHeightPossible) {
                        maxSeatToFloorHeightPossible = parseInt(seatToFloorHeight.max);
                    }
                }
            });

            // Обновляем интерфейс для высоты сиденья от пола
            if (minSeatToFloorHeightPossible !== Infinity) {
                minSeatToFloorHeightInput.min = minSeatToFloorHeightPossible;
                minSeatToFloorHeightValue.min = minSeatToFloorHeightPossible;
                minSeatToFloorHeightInput.value = minSeatToFloorHeightPossible;
                minSeatToFloorHeightValue.value = minSeatToFloorHeightPossible;
            } else {
                minSeatToFloorHeightInput.min = 100;
                minSeatToFloorHeightValue.min = 100;
                minSeatToFloorHeightInput.value = 100;
                minSeatToFloorHeightValue.value = 100;
            }

            if (maxSeatToFloorHeightPossible !== -Infinity) {
                maxSeatToFloorHeightInput.max = maxSeatToFloorHeightPossible;
                maxSeatToFloorHeightValue.max = maxSeatToFloorHeightPossible;
                maxSeatToFloorHeightInput.value = maxSeatToFloorHeightPossible;
                maxSeatToFloorHeightValue.value = maxSeatToFloorHeightPossible;
            } else {
                maxSeatToFloorHeightInput.max = 1800;
                maxSeatToFloorHeightValue.max = 1800;
                maxSeatToFloorHeightInput.value = 1800;
                maxSeatToFloorHeightValue.value = 1800;
            }

            // Пересчитываем min/max для габаритной глубины
            let minChairDepthPossible = Infinity;
            let maxChairDepthPossible = -Infinity;
            filteredByCategory.forEach(product => {
                const chairDepth = product.dimensions_details?.[0]?.chair_depth;
                if (chairDepth) {
                    if (chairDepth.min && !isNaN(parseInt(chairDepth.min)) && parseInt(chairDepth.min) < minChairDepthPossible) {
                        minChairDepthPossible = parseInt(chairDepth.min);
                    }
                    if (chairDepth.max && !isNaN(parseInt(chairDepth.max)) && parseInt(chairDepth.max) > maxChairDepthPossible) {
                        maxChairDepthPossible = parseInt(chairDepth.max);
                    }
                }
            });

            // Обновляем интерфейс для габаритной глубины
            if (minChairDepthPossible !== Infinity) {
                minChairDepthInput.min = minChairDepthPossible;
                minChairDepthValue.min = minChairDepthPossible;
                minChairDepthInput.value = minChairDepthPossible;
                minChairDepthValue.value = minChairDepthPossible;
            } else {
                minChairDepthInput.min = 100;
                minChairDepthValue.min = 100;
                minChairDepthInput.value = 100;
                minChairDepthValue.value = 100;
            }

            if (maxChairDepthPossible !== -Infinity) {
                maxChairDepthInput.max = maxChairDepthPossible;
                maxChairDepthValue.max = maxChairDepthPossible;
                maxChairDepthInput.value = maxChairDepthPossible;
                maxChairDepthValue.value = maxChairDepthPossible;
            } else {
                maxChairDepthInput.max = 1800;
                maxChairDepthValue.max = 1800;
                maxChairDepthInput.value = 1800;
                maxChairDepthValue.value = 1800;
            }

            // Пересчитываем min/max для глубины сиденья
            let minSeatDepthPossible = Infinity;
            let maxSeatDepthPossible = -Infinity;
            filteredByCategory.forEach(product => {
                const seatDepth = product.dimensions_details?.[0]?.seat_depth;
                if (seatDepth) {
                    if (seatDepth.min && !isNaN(parseInt(seatDepth.min)) && parseInt(seatDepth.min) < minSeatDepthPossible) {
                        minSeatDepthPossible = parseInt(seatDepth.min);
                    }
                    if (seatDepth.max && !isNaN(parseInt(seatDepth.max)) && parseInt(seatDepth.max) > maxSeatDepthPossible) {
                        maxSeatDepthPossible = parseInt(seatDepth.max);
                    }
                }
            });

            // Обновляем интерфейс для глубины сиденья
            if (minSeatDepthPossible !== Infinity) {
                minSeatDepthInput.min = minSeatDepthPossible;
                minSeatDepthValue.min = minSeatDepthPossible;
                minSeatDepthInput.value = minSeatDepthPossible;
                minSeatDepthValue.value = minSeatDepthPossible;
            } else {
                minSeatDepthInput.min = 100;
                minSeatDepthValue.min = 100;
                minSeatDepthInput.value = 100;
                minSeatDepthValue.value = 100;
            }

            if (maxSeatDepthPossible !== -Infinity) {
                maxSeatDepthInput.max = maxSeatDepthPossible;
                maxSeatDepthValue.max = maxSeatDepthPossible;
                maxSeatDepthInput.value = maxSeatDepthPossible;
                maxSeatDepthValue.value = maxSeatDepthPossible;
            } else {
                maxSeatDepthInput.max = 1800;
                maxSeatDepthValue.max = 1800;
                maxSeatDepthInput.value = 1800;
                maxSeatDepthValue.value = 1800;
            }

            // Пересчитываем min/max для ширины сиденья
            let minSeatWidthPossible = Infinity;
            let maxSeatWidthPossible = -Infinity;

            filteredByCategory.forEach(product => {
                const seatWidth = product.dimensions_details?.[0]?.seat_width;
                if (seatWidth) {
                    // Если есть min — используем его
                    if (seatWidth.min && !isNaN(parseInt(seatWidth.min))) {
                        const minVal = parseInt(seatWidth.min);
                        if (minVal < minSeatWidthPossible) {
                            minSeatWidthPossible = minVal;
                        }
                    }
                    // Если min нет, но есть max — используем max как min
                    else if (seatWidth.max && !isNaN(parseInt(seatWidth.max))) {
                        const maxVal = parseInt(seatWidth.max);
                        if (maxVal < minSeatWidthPossible) {
                            minSeatWidthPossible = maxVal;
                        }
                    }
                    // Всегда обновляем max
                    if (seatWidth.max && !isNaN(parseInt(seatWidth.max))) {
                        const maxVal = parseInt(seatWidth.max);
                        if (maxVal > maxSeatWidthPossible) {
                            maxSeatWidthPossible = maxVal;
                        }
                    }
                }
            });

            validProducts.forEach(product => {
                const seatWidth = product.dimensions_details?.[0]?.seat_width;
                console.log("Продукт:", product.name, "-> seat_width:", seatWidth);
            });

            // Обновляем интерфейс для ширины сиденья
            if (minSeatWidthPossible !== Infinity) {
                minSeatWidthInput.min = minSeatWidthPossible;
                minSeatWidthValue.min = minSeatWidthPossible;
                minSeatWidthInput.value = minSeatWidthPossible;
                minSeatWidthValue.value = minSeatWidthPossible;
            } else {
                minSeatWidthInput.min = 100;
                minSeatWidthValue.min = 100;
                minSeatWidthInput.value = 100;
                minSeatWidthValue.value = 100;
            }

            if (maxSeatWidthPossible !== -Infinity) {
                maxSeatWidthInput.max = maxSeatWidthPossible;
                maxSeatWidthValue.max = maxSeatWidthPossible;
                maxSeatWidthInput.value = maxSeatWidthPossible;
                maxSeatWidthValue.value = maxSeatWidthPossible;
            } else {
                maxSeatWidthInput.max = 1800;
                maxSeatWidthValue.max = 1800;
                maxSeatWidthInput.value = 1800;
                maxSeatWidthValue.value = 1800;
            }
        }


        document.addEventListener('DOMContentLoaded', function () {
            // Обработчики для кнопок сворачивания/разворачивания блоков фильтров
            document.querySelectorAll('.toggle-filter').forEach(button => {
                button.addEventListener('click', function () {
                    const targetId = this.getAttribute('data-target');
                    const targetBlock = document.getElementById(targetId);
                    const isHidden = !targetBlock.style.maxHeight || targetBlock.style.maxHeight === '0px' || targetBlock.style.maxHeight === '0';

                    if (isHidden) {
                        targetBlock.style.maxHeight = targetBlock.scrollHeight + 'px';
                        targetBlock.classList.add('expanded');
                        this.textContent = '−';
                    } else {
                        targetBlock.classList.remove('expanded');
                        setTimeout(() => {
                            targetBlock.style.maxHeight = '0px';
                        }, 200);
                        this.textContent = '+';
                    }
                });
            });

            const productsContainer = document.getElementById('products');
            if (!productsContainer) {
                console.error("Элемент #products не найден!");
                return;
            }

            // Обработчики для фильтров
            document.querySelectorAll('.armrest-filter, .mechanism-filter, .finish-filter, .category-filter, .load-filter, .diameter-filter').forEach(checkbox => {
                checkbox.addEventListener('change', filterProducts);
            });

            document.getElementById('searchInput').addEventListener('input', filterProducts);

            // Логика для сворачивания/разворачивания блока аналитики
            const toggleButton = document.getElementById('toggleAnalytics');
            const analyticsContent = document.getElementById('analyticsContent');
            let isCollapsed = false;
            toggleButton.addEventListener('click', () => {
                isCollapsed = !isCollapsed;
                if (isCollapsed) {
                    analyticsContent.classList.add('hidden');
                    toggleButton.textContent = 'Показать общую аналитику';
                } else {
                    analyticsContent.classList.remove('hidden');
                    toggleButton.textContent = 'Скрыть общую аналитику';
                }
            });

            // Загрузка товаров
            const products = [];
            const promises = knownProductsAllFiles.map(item => {
                return fetch(`products/${encodeURIComponent(item.category)}/${encodeURIComponent(item.name)}.json`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Ошибка загрузки ${item.name}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(product => {
                        product.category = item.category;
                        products.push(product);
                    })
                    .catch(error => {
                        console.error(`Ошибка загрузки ${item.name}:`, error);
                    });
            });

            Promise.all(promises)
                .then(() => {
                    validProducts = products.filter(p => {
                        if (!p || !p.unique_name || (Array.isArray(p.unique_name) && p.unique_name.length === 0)) {
                            console.warn("Товар отсеян на этапе валидации:", p);
                            return false;
                        }
                        return true;
                    });


                    validProducts.sort((a, b) => {
                        const aName = Array.isArray(a.unique_name) ? a.unique_name[0] : a.unique_name;
                        const bName = Array.isArray(b.unique_name) ? b.unique_name[0] : b.unique_name;
                        return aName.localeCompare(bName, 'ru');
                    });

                    let minPossible = Infinity;
                    let maxPossible = -Infinity;
                    validProducts.forEach(product => {
                        const chairHeight = product.dimensions_details?.[0]?.chair_height;
                        if (chairHeight) {
                            if (chairHeight.min && !isNaN(parseInt(chairHeight.min)) && parseInt(chairHeight.min) < minPossible) {
                                minPossible = parseInt(chairHeight.min);
                            }
                            if (chairHeight.max && !isNaN(parseInt(chairHeight.max)) && parseInt(chairHeight.max) > maxPossible) {
                                maxPossible = parseInt(chairHeight.max);
                            }
                        }
                    });
                    console.log("Всего товаров после валидации:", validProducts.length);


                    // Устанавливаем найденные min/max для ползунков и числовых полей
                    minHeightInput = document.getElementById('minHeight');
                    maxHeightInput = document.getElementById('maxHeight');
                    minHeightValue = document.getElementById('minHeightValue');
                    maxHeightValue = document.getElementById('maxHeightValue');


                    if (minPossible !== Infinity) {
                        minHeightInput.min = minPossible;
                        minHeightValue.min = minPossible;
                        minHeightInput.value = minPossible;
                        minHeightValue.value = minPossible;
                    } else {
                        minHeightInput.value = 400;
                        minHeightValue.value = 400;
                    }

                    if (maxPossible !== -Infinity) {
                        maxHeightInput.max = maxPossible;
                        maxHeightValue.max = maxPossible;
                        maxHeightInput.value = maxPossible;
                        maxHeightValue.value = maxPossible;
                    } else {
                        maxHeightInput.value = 1800;
                        maxHeightValue.value = 1800;
                    }

                    // Синхронизация ползунков и полей ввода
                    minHeightInput.addEventListener('input', () => {
                        isChairHeightChanged = true;
                        if (parseInt(minHeightInput.value) > parseInt(maxHeightInput.value)) {
                            minHeightInput.value = maxHeightInput.value;
                        }
                        minHeightValue.value = minHeightInput.value;
                        filterProducts();
                    });

                    maxHeightInput.addEventListener('input', () => {
                        isChairHeightChanged = true;
                        if (parseInt(maxHeightInput.value) < parseInt(minHeightInput.value)) {
                            maxHeightInput.value = minHeightInput.value;
                        }
                        maxHeightValue.value = maxHeightInput.value;
                        filterProducts();
                    });

                    minHeightValue.addEventListener('change', () => {
                        isChairHeightChanged = true;
                        if (parseInt(minHeightValue.value) > parseInt(maxHeightInput.value)) {
                            minHeightValue.value = maxHeightInput.value;
                        }
                        minHeightInput.value = minHeightValue.value;
                        filterProducts();
                    });

                    maxHeightValue.addEventListener('change', () => {
                        isChairHeightChanged = true;
                        if (parseInt(maxHeightValue.value) < parseInt(minHeightInput.value)) {
                            maxHeightValue.value = minHeightInput.value;
                        }
                        maxHeightInput.value = maxHeightValue.value;
                        filterProducts();
                    });

                    //для ширины сиденья с подлокотниками
                    let minSeatWidthWithArmrestsPossible = Infinity;
                    validProducts.forEach(product => {
                        const dimensions = product.dimensions_details?.[0] || {};
                        const seatWidthWithArmrests = dimensions.seat_width_with_armrests;
                        const diameterCross = dimensions.diameter_cross;
                        const runnersWidth = dimensions.runners_width;
                        const seatWidth = dimensions.seat_width;
                        const chairDepth = dimensions.chair_depth;

                        // Проверяем все возможные поля, где может быть указана габаритная ширина
                        const possibleWidths = [
                            seatWidthWithArmrests?.min,
                            diameterCross?.min,
                            runnersWidth?.min,
                            seatWidth?.min,
                            chairDepth?.min,
                        ].filter(w => w !== undefined && w !== null && !isNaN(parseInt(w)));

                        if (possibleWidths.length > 0) {
                            const currentMin = Math.min(...possibleWidths.map(w => parseInt(w)));
                            if (currentMin < minSeatWidthWithArmrestsPossible) {
                                minSeatWidthWithArmrestsPossible = currentMin;
                            }
                        }
                    });
                    let maxSeatWidthWithArmrestsPossible = -Infinity;
                    validProducts.forEach(product => {
                        const dimensions = product.dimensions_details?.[0] || {};
                        const seatWidthWithArmrests = dimensions.seat_width_with_armrests;
                        const diameterCross = dimensions.diameter_cross;
                        const runnersWidth = dimensions.runners_width;
                        const seatWidth = dimensions.seat_width;
                        const chairDepth = dimensions.chair_depth;

                        // Проверяем все возможные поля, где может быть указана габаритная ширина
                        const possibleWidths = [
                            seatWidthWithArmrests?.max,
                            diameterCross?.max,
                            runnersWidth?.max,
                            seatWidth?.max,
                            chairDepth?.max,
                        ].filter(w => w !== undefined && w !== null && !isNaN(parseInt(w)));

                        if (possibleWidths.length > 0) {
                            const currentMax = Math.max(...possibleWidths.map(w => parseInt(w)));
                            if (currentMax > maxSeatWidthWithArmrestsPossible) {
                                maxSeatWidthWithArmrestsPossible = currentMax;
                            }
                        }
                    });





                    // Устанавливаем найденные min/max для ползунков и числовых полей
                    minSeatWidthWithArmrestsInput = document.getElementById('minSeatWidthWithArmrests');
                    maxSeatWidthWithArmrestsInput = document.getElementById('maxSeatWidthWithArmrests');
                    minSeatWidthWithArmrestsValue = document.getElementById('minSeatWidthWithArmrestsValue');
                    maxSeatWidthWithArmrestsValue = document.getElementById('maxSeatWidthWithArmrestsValue');


                    if (minSeatWidthWithArmrestsPossible !== Infinity) {
                        minSeatWidthWithArmrestsInput.min = minSeatWidthWithArmrestsPossible;
                        minSeatWidthWithArmrestsValue.min = minSeatWidthWithArmrestsPossible;
                        minSeatWidthWithArmrestsInput.value = minSeatWidthWithArmrestsPossible;
                        minSeatWidthWithArmrestsValue.value = minSeatWidthWithArmrestsPossible;
                    } else {
                        minSeatWidthWithArmrestsInput.min = 100;
                        minSeatWidthWithArmrestsValue.min = 100;
                        minSeatWidthWithArmrestsInput.value = 100;
                        minSeatWidthWithArmrestsValue.value = 100;
                    }

                    if (maxSeatWidthWithArmrestsPossible !== -Infinity) {
                        maxSeatWidthWithArmrestsInput.max = maxSeatWidthWithArmrestsPossible;
                        maxSeatWidthWithArmrestsValue.max = maxSeatWidthWithArmrestsPossible;
                        maxSeatWidthWithArmrestsInput.value = maxSeatWidthWithArmrestsPossible;
                        maxSeatWidthWithArmrestsValue.value = maxSeatWidthWithArmrestsPossible;
                    } else {
                        maxSeatWidthWithArmrestsInput.max = 1800;
                        maxSeatWidthWithArmrestsValue.max = 1800;
                        maxSeatWidthWithArmrestsInput.value = 1800;
                        maxSeatWidthWithArmrestsValue.value = 1800;
                    }

                    // Синхронизация ползунков и числовых полей для ширины сиденья с подлокотниками
                    minSeatWidthWithArmrestsInput.addEventListener('input', () => {
                        isSeatWidthWithArmrestsChanged = true;
                        if (parseInt(minSeatWidthWithArmrestsInput.value) > parseInt(maxSeatWidthWithArmrestsInput.value)) {
                            minSeatWidthWithArmrestsInput.value = maxSeatWidthWithArmrestsInput.value;
                        }
                        minSeatWidthWithArmrestsValue.value = minSeatWidthWithArmrestsInput.value;
                        filterProducts();
                    });

                    maxSeatWidthWithArmrestsInput.addEventListener('input', () => {
                        isSeatWidthWithArmrestsChanged = true;
                        if (parseInt(maxSeatWidthWithArmrestsInput.value) < parseInt(minSeatWidthWithArmrestsInput.value)) {
                            maxSeatWidthWithArmrestsInput.value = minSeatWidthWithArmrestsInput.value;
                        }
                        maxSeatWidthWithArmrestsValue.value = maxSeatWidthWithArmrestsInput.value;
                        filterProducts();
                    });

                    minSeatWidthWithArmrestsValue.addEventListener('change', () => {
                        isSeatWidthWithArmrestsChanged = true;
                        if (parseInt(minSeatWidthWithArmrestsValue.value) > parseInt(maxSeatWidthWithArmrestsInput.value)) {
                            minSeatWidthWithArmrestsValue.value = maxSeatWidthWithArmrestsInput.value;
                        }
                        minSeatWidthWithArmrestsInput.value = minSeatWidthWithArmrestsValue.value;
                        filterProducts();
                    });

                    maxSeatWidthWithArmrestsValue.addEventListener('change', () => {
                        isSeatWidthWithArmrestsChanged = true;
                        if (parseInt(maxSeatWidthWithArmrestsValue.value) < parseInt(minSeatWidthWithArmrestsInput.value)) {
                            maxSeatWidthWithArmrestsValue.value = minSeatWidthWithArmrestsInput.value;
                        }
                        maxSeatWidthWithArmrestsInput.value = maxSeatWidthWithArmrestsValue.value;
                        filterProducts();
                    });

                    // Аналогично для высоты сиденья от пола
                    let minSeatToFloorHeightPossible = Infinity;
                    let maxSeatToFloorHeightPossible = -Infinity;
                    validProducts.forEach(product => {
                        const seatToFloorHeight = product.dimensions_details?.[0]?.seat_to_floor_height;
                        if (seatToFloorHeight) {
                            if (seatToFloorHeight.min && !isNaN(parseInt(seatToFloorHeight.min)) && parseInt(seatToFloorHeight.min) < minSeatToFloorHeightPossible) {
                                minSeatToFloorHeightPossible = parseInt(seatToFloorHeight.min);
                            }
                            if (seatToFloorHeight.max && !isNaN(parseInt(seatToFloorHeight.max)) && parseInt(seatToFloorHeight.max) > maxSeatToFloorHeightPossible) {
                                maxSeatToFloorHeightPossible = parseInt(seatToFloorHeight.max);
                            }
                        }
                    });


                    // Устанавливаем найденные min/max для ползунков и числовых полей
                    minSeatToFloorHeightInput = document.getElementById('minSeatToFloorHeight');
                    maxSeatToFloorHeightInput = document.getElementById('maxSeatToFloorHeight');
                    minSeatToFloorHeightValue = document.getElementById('minSeatToFloorHeightValue');
                    maxSeatToFloorHeightValue = document.getElementById('maxSeatToFloorHeightValue');

                    if (minSeatToFloorHeightPossible !== Infinity) {
                        minSeatToFloorHeightInput.min = minSeatToFloorHeightPossible;
                        minSeatToFloorHeightValue.min = minSeatToFloorHeightPossible;
                        minSeatToFloorHeightInput.value = minSeatToFloorHeightPossible;
                        minSeatToFloorHeightValue.value = minSeatToFloorHeightPossible;
                    } else {
                        minSeatToFloorHeightInput.value = 100;
                        minSeatToFloorHeightValue.value = 100;
                    }

                    if (maxSeatToFloorHeightPossible !== -Infinity) {
                        maxSeatToFloorHeightInput.max = maxSeatToFloorHeightPossible;
                        maxSeatToFloorHeightValue.max = maxSeatToFloorHeightPossible;
                        maxSeatToFloorHeightInput.value = maxSeatToFloorHeightPossible;
                        maxSeatToFloorHeightValue.value = maxSeatToFloorHeightPossible;
                        minChairDepthInput = document.getElementById('minChairDepth');

                    } else {
                        maxSeatToFloorHeightInput.value = 1800;
                        maxSeatToFloorHeightValue.value = 1800;
                    }




                    // Синхронизация ползунков и числовых полей для высоты сиденья от пола
                    minSeatToFloorHeightInput.addEventListener('input', () => {
                        isSeatToFloorHeightChanged = true;
                        if (parseInt(minSeatToFloorHeightInput.value) > parseInt(maxSeatToFloorHeightInput.value)) {
                            minSeatToFloorHeightInput.value = maxSeatToFloorHeightInput.value;
                        }
                        minSeatToFloorHeightValue.value = minSeatToFloorHeightInput.value;
                        filterProducts();
                    });

                    maxSeatToFloorHeightInput.addEventListener('input', () => {
                        isSeatToFloorHeightChanged = true;
                        if (parseInt(maxSeatToFloorHeightInput.value) < parseInt(minSeatToFloorHeightInput.value)) {
                            maxSeatToFloorHeightInput.value = minSeatToFloorHeightInput.value;
                        }
                        maxSeatToFloorHeightValue.value = maxSeatToFloorHeightInput.value;
                        filterProducts();
                    });

                    minSeatToFloorHeightValue.addEventListener('change', () => {
                        isSeatToFloorHeightChanged = true;
                        if (parseInt(minSeatToFloorHeightValue.value) > parseInt(maxSeatToFloorHeightInput.value)) {
                            minSeatToFloorHeightValue.value = maxSeatToFloorHeightInput.value;
                        }
                        minSeatToFloorHeightInput.value = minSeatToFloorHeightValue.value;
                        filterProducts();
                    });

                    maxSeatToFloorHeightValue.addEventListener('change', () => {
                        isSeatToFloorHeightChanged = true;
                        if (parseInt(maxSeatToFloorHeightValue.value) < parseInt(minSeatToFloorHeightInput.value)) {
                            maxSeatToFloorHeightValue.value = minSeatToFloorHeightInput.value;
                        }
                        maxSeatToFloorHeightInput.value = maxSeatToFloorHeightValue.value;
                        filterProducts();
                    });



                    // Пересчитываем min/max для габаритной глубины
                    let minChairDepthPossible = Infinity;
                    let maxChairDepthPossible = -Infinity;
                    validProducts.forEach(product => {
                        const chairDepth = product.dimensions_details?.[0]?.chair_depth;
                        if (chairDepth) {
                            if (chairDepth.min && !isNaN(parseInt(chairDepth.min)) && parseInt(chairDepth.min) < minChairDepthPossible) {
                                minChairDepthPossible = parseInt(chairDepth.min);
                            }
                            if (chairDepth.max && !isNaN(parseInt(chairDepth.max)) && parseInt(chairDepth.max) > maxChairDepthPossible) {
                                maxChairDepthPossible = parseInt(chairDepth.max);
                            }
                        }
                    });


                    minChairDepthInput = document.getElementById('minChairDepth');
                    maxChairDepthInput = document.getElementById('maxChairDepth');
                    minChairDepthValue = document.getElementById('minChairDepthValue');
                    maxChairDepthValue = document.getElementById('maxChairDepthValue');


                    // Обновляем интерфейс для габаритной глубины
                    if (minChairDepthPossible !== Infinity) {
                        minChairDepthInput.min = minChairDepthPossible;
                        minChairDepthValue.min = minChairDepthPossible;
                        minChairDepthInput.value = minChairDepthPossible;
                        minChairDepthValue.value = minChairDepthPossible;
                    } else {
                        minChairDepthInput.min = 100;
                        minChairDepthValue.min = 100;
                        minChairDepthInput.value = 100;
                        minChairDepthValue.value = 100;
                    }

                    if (maxChairDepthPossible !== -Infinity) {
                        maxChairDepthInput.max = maxChairDepthPossible;
                        maxChairDepthValue.max = maxChairDepthPossible;
                        maxChairDepthInput.value = maxChairDepthPossible;
                        maxChairDepthValue.value = maxChairDepthPossible;
                    } else {
                        maxChairDepthInput.max = 1800;
                        maxChairDepthValue.max = 1800;
                        maxChairDepthInput.value = 1800;
                        maxChairDepthValue.value = 1800;
                    }

                    // Синхронизация ползунков и числовых полей для габаритной глубины
                    minChairDepthInput.addEventListener('input', () => {
                        isChairDepthChanged = true;
                        if (parseInt(minChairDepthInput.value) > parseInt(maxChairDepthInput.value)) {
                            minChairDepthInput.value = maxChairDepthInput.value;
                        }
                        minChairDepthValue.value = minChairDepthInput.value;
                        filterProducts();
                    });
                    maxChairDepthInput.addEventListener('input', () => {
                        isChairDepthChanged = true;
                        if (parseInt(maxChairDepthInput.value) < parseInt(minChairDepthInput.value)) {
                            maxChairDepthInput.value = minChairDepthInput.value;
                        }
                        maxChairDepthValue.value = maxChairDepthInput.value;
                        filterProducts();
                    });
                    minChairDepthValue.addEventListener('change', () => {
                        isChairDepthChanged = true;
                        if (parseInt(minChairDepthValue.value) > parseInt(maxChairDepthInput.value)) {
                            minChairDepthValue.value = maxChairDepthInput.value;
                        }
                        minChairDepthInput.value = minChairDepthValue.value;
                        filterProducts();
                    });
                    maxChairDepthValue.addEventListener('change', () => {
                        isChairDepthChanged = true;
                        if (parseInt(maxChairDepthValue.value) < parseInt(minChairDepthInput.value)) {
                            maxChairDepthValue.value = minChairDepthInput.value;
                        }
                        maxChairDepthInput.value = maxChairDepthValue.value;
                        filterProducts();
                    });

                    // Пересчитываем min/max для глубины сиденья
                    let minSeatDepthPossible = Infinity;
                    let maxSeatDepthPossible = -Infinity;
                    validProducts.forEach(product => {
                        const seatDepth = product.dimensions_details?.[0]?.seat_depth;
                        if (seatDepth) {
                            if (seatDepth.min && !isNaN(parseInt(seatDepth.min)) && parseInt(seatDepth.min) < minSeatDepthPossible) {
                                minSeatDepthPossible = parseInt(seatDepth.min);
                            }
                            if (seatDepth.max && !isNaN(parseInt(seatDepth.max)) && parseInt(seatDepth.max) > maxSeatDepthPossible) {
                                maxSeatDepthPossible = parseInt(seatDepth.max);
                            }
                        }
                    });


                    minSeatDepthInput = document.getElementById('minSeatDepth');
                    maxSeatDepthInput = document.getElementById('maxSeatDepth');
                    minSeatDepthValue = document.getElementById('minSeatDepthValue');
                    maxSeatDepthValue = document.getElementById('maxSeatDepthValue');


                    // Обновляем интерфейс для глубины сиденья
                    if (minSeatDepthPossible !== Infinity) {
                        minSeatDepthInput.min = minSeatDepthPossible;
                        minSeatDepthValue.min = minSeatDepthPossible;
                        minSeatDepthInput.value = minSeatDepthPossible;
                        minSeatDepthValue.value = minSeatDepthPossible;
                    } else {
                        minSeatDepthInput.min = 100;
                        minSeatDepthValue.min = 100;
                        minSeatDepthInput.value = 100;
                        minSeatDepthValue.value = 100;
                    }

                    if (maxSeatDepthPossible !== -Infinity) {
                        maxSeatDepthInput.max = maxSeatDepthPossible;
                        maxSeatDepthValue.max = maxSeatDepthPossible;
                        maxSeatDepthInput.value = maxSeatDepthPossible;
                        maxSeatDepthValue.value = maxSeatDepthPossible;
                    } else {
                        maxSeatDepthInput.max = 1800;
                        maxSeatDepthValue.max = 1800;
                        maxSeatDepthInput.value = 1800;
                        maxSeatDepthValue.value = 1800;
                    }

                    // Синхронизация ползунков и числовых полей для глубины сиденья
                    minSeatDepthInput.addEventListener('input', () => {
                        isSeatDepthChanged = true;
                        if (parseInt(minSeatDepthInput.value) > parseInt(maxSeatDepthInput.value)) {
                            minSeatDepthInput.value = maxSeatDepthInput.value;
                        }
                        minSeatDepthValue.value = minSeatDepthInput.value;
                        filterProducts();
                    });
                    maxSeatDepthInput.addEventListener('input', () => {
                        isSeatDepthChanged = true;
                        if (parseInt(maxSeatDepthInput.value) < parseInt(minSeatDepthInput.value)) {
                            maxSeatDepthInput.value = minSeatDepthInput.value;
                        }
                        maxSeatDepthValue.value = maxSeatDepthInput.value;
                        filterProducts();
                    });
                    minSeatDepthValue.addEventListener('change', () => {
                        isSeatDepthChanged = true;
                        if (parseInt(minSeatDepthValue.value) > parseInt(maxSeatDepthInput.value)) {
                            minSeatDepthValue.value = maxSeatDepthInput.value;
                        }
                        minSeatDepthInput.value = minSeatDepthValue.value;
                        filterProducts();
                    });
                    maxSeatDepthValue.addEventListener('change', () => {
                        isSeatDepthChanged = true;
                        if (parseInt(maxSeatDepthValue.value) < parseInt(minSeatDepthInput.value)) {
                            maxSeatDepthValue.value = minSeatDepthInput.value;
                        }
                        maxSeatDepthInput.value = maxSeatDepthValue.value;
                        filterProducts();
                    });


                    // Пересчитываем min/max для ширины сиденья
                    let minSeatWidthPossible = Infinity;
                    let maxSeatWidthPossible = -Infinity;
                    validProducts.forEach(product => {
                        const seatWidth = product.dimensions_details?.[0]?.seat_width;
                        if (seatWidth) {
                            if (seatWidth.min && !isNaN(parseInt(seatWidth.min)) && parseInt(seatWidth.min) < minSeatWidthPossible) {
                                minSeatWidthPossible = parseInt(seatWidth.min);
                            }
                            if (seatWidth.max && !isNaN(parseInt(seatWidth.max)) && parseInt(seatWidth.max) > maxSeatWidthPossible) {
                                maxSeatWidthPossible = parseInt(seatWidth.max);
                            }
                        }
                    });

                    minSeatWidthInput = document.getElementById('minSeatWidth');
                    maxSeatWidthInput = document.getElementById('maxSeatWidth');
                    minSeatWidthValue = document.getElementById('minSeatWidthValue');
                    maxSeatWidthValue = document.getElementById('maxSeatWidthValue');

                    // Обновляем интерфейс для ширины сиденья
                    if (minSeatWidthPossible !== Infinity) {
                        minSeatWidthInput.min = minSeatWidthPossible;
                        minSeatWidthValue.min = minSeatWidthPossible;
                        minSeatWidthInput.value = minSeatWidthPossible;
                        minSeatWidthValue.value = minSeatWidthPossible;
                    } else {
                        minSeatWidthInput.min = 100;
                        minSeatWidthValue.min = 100;
                        minSeatWidthInput.value = 100;
                        minSeatWidthValue.value = 100;
                    }

                    if (maxSeatWidthPossible !== -Infinity) {
                        maxSeatWidthInput.max = maxSeatWidthPossible;
                        maxSeatWidthValue.max = maxSeatWidthPossible;
                        maxSeatWidthInput.value = maxSeatWidthPossible;
                        maxSeatWidthValue.value = maxSeatWidthPossible;
                    } else {
                        maxSeatWidthInput.max = 1800;
                        maxSeatWidthValue.max = 1800;
                        maxSeatWidthInput.value = 1800;
                        maxSeatWidthValue.value = 1800;
                    }

                    // Синхронизация ползунков и числовых полей для ширины сиденья
                    minSeatWidthInput.addEventListener('input', () => {
                        isSeatWidthChanged = true;
                        if (parseInt(minSeatWidthInput.value) > parseInt(maxSeatWidthInput.value)) {
                            minSeatWidthInput.value = maxSeatWidthInput.value;
                        }
                        minSeatWidthValue.value = minSeatWidthInput.value;
                        filterProducts();
                    });
                    maxSeatWidthInput.addEventListener('input', () => {
                        isSeatWidthChanged = true;
                        if (parseInt(maxSeatWidthInput.value) < parseInt(minSeatWidthInput.value)) {
                            maxSeatWidthInput.value = minSeatWidthInput.value;
                        }
                        maxSeatWidthValue.value = maxSeatWidthInput.value;
                        filterProducts();
                    });
                    minSeatWidthValue.addEventListener('change', () => {
                        isSeatWidthChanged = true;
                        if (parseInt(minSeatWidthValue.value) > parseInt(maxSeatWidthInput.value)) {
                            minSeatWidthValue.value = maxSeatWidthInput.value;
                        }
                        minSeatWidthInput.value = minSeatWidthValue.value;
                        filterProducts();
                    });
                    maxSeatWidthValue.addEventListener('change', () => {
                        isSeatWidthChanged = true;
                        if (parseInt(maxSeatWidthValue.value) < parseInt(minSeatWidthInput.value)) {
                            maxSeatWidthValue.value = minSeatWidthInput.value;
                        }
                        maxSeatWidthInput.value = maxSeatWidthValue.value;
                        filterProducts();
                    });



                    // Построение диаграммы и генерация карточек
                    buildOverallChart(validProducts);
                    recalculateSliderValues();
                    filterProducts();
                })
                .catch(error => {
                    console.error('Ошибка загрузки данных:', error);
                    productsContainer.innerHTML = '<p>Не удалось загрузить товары. Попробуйте позже</p>';
                });

            function searchInObject(obj, searchTerm) {
                if (!obj) return false;
                if (typeof obj === 'string') {
                    return normalizeSearchTerm(obj).includes(searchTerm);
                }
                if (Array.isArray(obj)) {
                    return obj.some(item => searchInObject(item, searchTerm));
                }
                if (typeof obj === 'object') {
                    return Object.values(obj).some(value => searchInObject(value, searchTerm));
                }
                return false;
            }

            // Функция фильтрации
            function filterProducts() {
                // Получаем значения из ползунков и числовых полей
                const minHeight = parseInt(minHeightInput.value);
                const maxHeight = parseInt(maxHeightInput.value);
                const minSeatWidthWithArmrests = parseInt(minSeatWidthWithArmrestsInput.value);
                const maxSeatWidthWithArmrests = parseInt(maxSeatWidthWithArmrestsInput.value);
                const minSeatToFloorHeight = parseInt(minSeatToFloorHeightInput.value);
                const maxSeatToFloorHeight = parseInt(maxSeatToFloorHeightInput.value);
                const minChairDepth = parseInt(minChairDepthInput.value);
                const maxChairDepth = parseInt(maxChairDepthInput.value);
                const minSeatDepth = parseInt(minSeatDepthInput.value);
                const maxSeatDepth = parseInt(maxSeatDepthInput.value);
                const minSeatWidth = parseInt(minSeatWidthInput.value);
                const maxSeatWidth = parseInt(maxSeatWidthInput.value);


                if (!minHeightInput || !maxHeightInput || !minHeightValue || !maxHeightValue) {
                    console.error("Один или несколько элементов не найдены!");
                    return;
                }

                const searchInput = document.getElementById('searchInput').value.trim();
                const searchTerms = searchInput.split(/,\s*/).map(term => normalizeSearchTerm(term)).filter(term => term.length > 0);
                // Получаем значения новых фильтров
                const specialOfferFilters = Array.from(document.querySelectorAll('.special-offer-filter:checked')).map(el => el.value);
                console.log('Нормализованные термы поиска:', searchTerms);
                const min = minHeightInput ? parseInt(minHeightInput.value) : 300;
                const max = maxHeightInput ? parseInt(maxHeightInput.value) : 1600;
                const minSliderValue = parseInt(minHeightInput.min);
                const maxSliderValue = parseInt(maxHeightInput.max);
                const armrestFilters = Array.from(document.querySelectorAll('.armrest-filter:checked')).map(el => el.value);
                const mechanismFilters = Array.from(document.querySelectorAll('.mechanism-filter:checked')).map(el => el.value);
                const finishFilters = Array.from(document.querySelectorAll('.finish-filter:checked')).map(el => el.value);
                const loadFilters = Array.from(document.querySelectorAll('.load-filter:checked')).map(el => el.value);
                const diameterFilters = Array.from(document.querySelectorAll('.diameter-filter:checked')).map(el => el.value);
                const selectedCategories = Array.from(document.querySelectorAll('.category-filter:checked')).map(el => el.value);

                let filtered = [];
                if (selectedCategories.length > 0) {
                    filtered = validProducts.filter(product =>
                        product.category && selectedCategories.includes(product.category)
                    );
                }
                // Фильтрация по специальным предложениям
                if (specialOfferFilters.length > 0) {
                    filtered = filtered.filter(product => {
                        const hasClean = product.lost?.[0]?.clean === true;
                        const hasLimit = product.lost?.[0]?.limit === true;

                        // Показываем, если есть хотя бы один из выбранных индикаторов
                        return specialOfferFilters.some(filter =>
                            (filter === "clean" && hasClean) ||
                            (filter === "limit" && hasLimit)
                        );
                    });
                }
                // recalculateSliderValues(filtered);

                console.log("Товары после фильтрации по категории:", filtered.map(p => p.unique_name));






                // let filtered = selectedCategories.length > 0
                //     ? validProducts.filter(product => product.category && selectedCategories.includes(product.category))
                //     : validProducts;

                // Фильтрация по подлокотникам, конструктиву и исполнению

                // При такой фильтрации будет происходить полное добавление
                // if (armrestFilters.length > 0 || mechanismFilters.length > 0 || finishFilters.length > 0) {
                //     filtered = filtered.filter(product => {
                //         let armrestMatch = armrestFilters.length === 0;
                //         let mechanismMatch = mechanismFilters.length === 0;
                //         let finishMatch = finishFilters.length === 0;

                //         if (armrestFilters.length > 0) {
                //             armrestMatch = armrestFilters.some(filter => {
                //                 const patterns = filter.split('|');
                //                 const uniqueName = Array.isArray(product.unique_name) ? product.unique_name[0].toLowerCase() : product.unique_name.toLowerCase();
                //                 return patterns.some(pattern => uniqueName.includes(pattern.toLowerCase()));
                //             });
                //         }

                //         if (mechanismFilters.length > 0) {
                //             mechanismMatch = mechanismFilters.some(filter => {
                //                 const patterns = filter.split('|');
                //                 const uniqueName = Array.isArray(product.unique_name) ? product.unique_name[0].toLowerCase() : product.unique_name.toLowerCase();
                //                 return patterns.some(pattern => uniqueName.includes(pattern.toLowerCase()));
                //             });
                //         }

                //         if (finishFilters.length > 0) {
                //             finishMatch = finishFilters.some(filter => {
                //                 const patterns = filter.split('|');
                //                 const fieldsToCheck = [
                //                     product.unique_name?.[0]?.toLowerCase(),
                //                     product.namefile?.[0]?.toLowerCase(),
                //                     product.name?.[0]?.toLowerCase(),
                //                 ];
                //                 return fieldsToCheck.some(field =>
                //                     field && patterns.some(pattern =>
                //                         field.includes(pattern.toLowerCase())
                //                     )
                //                 );
                //             });
                //         }

                //         return armrestMatch && mechanismMatch && finishMatch;
                //     });
                // }

                //                 // Фильтрация по подлокотникам, конструктиву и исполнению
                //                 if (armrestFilters.length > 0 || mechanismFilters.length > 0 || finishFilters.length > 0 || loadFilters.length > 0) {
                //                     filtered = filtered.filter(product => {
                //                         const uniqueName = (Array.isArray(product.unique_name) ? product.unique_name[0] : product.unique_name).toLowerCase();

                //                         // Фильтрация по подлокотникам (если выбраны)
                //                         let armrestMatch = true;
                //                         if (armrestFilters.length > 0) {
                //                             const firstWord = uniqueName.split(/\s+/)[0].toLowerCase();
                //                             // Если первое слово совпадает с любым из фильтров — исключаем из результата
                //                             const isFirstWordInFilter = armrestFilters.some(filter => {
                //                                 const patterns = filter.split('|');
                //                                 return patterns.some(pattern => firstWord === pattern.toLowerCase());
                //                             });
                //                             if (isFirstWordInFilter) {
                //                                 armrestMatch = false; // Исключаем из результата
                //                             } else {
                //                                 // Обычная логика фильтрации
                //                                 armrestMatch = armrestFilters.every(filter => {
                //                                     const patterns = filter.split('|');
                //                                     const cleanedUniqueName = uniqueName.replace(/\s*([сc]н|ch)[-\s]?\d*\s*/gi, ' ').trim();
                //                                     return patterns.some(pattern => {
                //                                         const lowerPattern = pattern.toLowerCase();
                //                                         const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                //                                         return regex.test(cleanedUniqueName);
                //                                     });
                //                                 });
                //                             }
                //                         }


                //                         // Проверяем конструктив (если выбран)
                //                         let mechanismMatch = mechanismFilters.length === 0;
                //                         if (mechanismFilters.length > 0) {
                //                             const cleanedUniqueName = uniqueName
                //                                 .replace(/\s*([мm]b|mb)[-\s]?\d*\s*/gi, ' ') // Убираем MB с цифрами (например, А-001-MB)
                //                                 .trim()
                //                                 .toLowerCase();
                //                             console.log(`Исходное имя: "${uniqueName}", Очищенное: "${cleanedUniqueName}"`);

                //                             mechanismMatch = mechanismFilters.every(filter => {
                //                                 const patterns = filter.split('|');
                //                                 return patterns.some(pattern => {
                //                                     const lowerPattern = pattern.toLowerCase().trim();
                //                                     const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                //                                     const isMatch = regex.test(cleanedUniqueName);
                //                                     console.log(`Проверка: "${cleanedUniqueName}" на "${lowerPattern}" → ${isMatch}`);
                //                                     return isMatch;
                //                                 });
                //                             });
                //                         }


                //                         // Проверяем исполнение (если выбрано)
                // // Внутри функции filterProducts, в блоке проверки finishMatch:
                // let finishMatch = true;
                // if (finishFilters.length > 0) {
                //     const cleanedUniqueName = uniqueName.toLowerCase();
                //     finishMatch = finishFilters.every(filter => {
                //         const patterns = filter.split('|');
                //         return patterns.some(pattern => {
                //             const lowerPattern = pattern.toLowerCase().trim();
                //             // Для "хрома" отдельная логика
                //             if (lowerPattern === 'хром' || lowerPattern === 'ch') {
                //                 // Ищем "ch" или "хром" как отдельное слово, но не в составе артикула или других слов
                //                 const regex = /(^|\s)(ch|хром)(\s|$)/i;
                //                 return regex.test(cleanedUniqueName);
                //             }
                //             // Для остальных фильтров — стандартная логика
                //             const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                //             return regex.test(cleanedUniqueName);
                //         });
                //     });
                // }


                //  // Проверяем нагрузку (если выбрана)
                // let loadMatch = true;
                // if (loadFilters.length > 0) {
                //     const maxLoad = product.guarantee?.[0]?.max_load;
                //     if (!maxLoad) {
                //         loadMatch = false;
                //     } else {
                //         // Если выбран "other", то пропускаем товары, у которых max_load не входит в стандартный список
                //         const standardLoads = ["90", "120", "130", "150", "180", "210"];
                //         const isOtherSelected = loadFilters.includes("other");
                //         const isStandardLoad = standardLoads.includes(String(maxLoad));

                //         if (isOtherSelected && !isStandardLoad) {
                //             loadMatch = true; // Пропускаем, если нагрузка нестандартная и выбран "other"
                //         } else if (!isOtherSelected && isStandardLoad) {
                //             loadMatch = loadFilters.some(load => String(maxLoad) === load); // Стандартная логика
                //         } else {
                //             loadMatch = false;
                //         }
                //     }
                // }





                //                         return armrestMatch && mechanismMatch && finishMatch && loadMatch;
                //                     });
                //                 }
                // Фильтрация по подлокотникам, конструктиву и исполнению
                if (armrestFilters.length > 0 || mechanismFilters.length > 0 || finishFilters.length > 0 || loadFilters.length > 0 || diameterFilters.length > 0) {
                    filtered = filtered.filter(product => {
                        const uniqueName = (Array.isArray(product.unique_name) ? product.unique_name[0] : product.unique_name).toLowerCase();

                        // Фильтрация по подлокотникам (если выбраны)
                        let armrestMatch = true;
                        if (armrestFilters.length > 0) {
                            const firstWord = uniqueName.split(/\s+/)[0].toLowerCase();
                            const isFirstWordInFilter = armrestFilters.some(filter => {
                                const patterns = filter.split('|');
                                return patterns.some(pattern => firstWord === pattern.toLowerCase());
                            });
                            if (isFirstWordInFilter) {
                                armrestMatch = false;
                            } else {
                                armrestMatch = armrestFilters.every(filter => {
                                    const patterns = filter.split('|');
                                    const cleanedUniqueName = uniqueName.replace(/\s*([сc]н|ch)[-\s]?\d*\s*/gi, ' ').trim();
                                    return patterns.some(pattern => {
                                        const lowerPattern = pattern.toLowerCase();
                                        const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                                        return regex.test(cleanedUniqueName);
                                    });
                                });
                            }
                        }

                        // Проверяем "подголовник" по всем текстовым полям
                        let podgоловnikMatch = true;
                        if (mechanismFilters.includes("подг|подголовник|подголовником")) {
                            podgоловnikMatch = searchInObject(product, "подголовник");
                        }

                        // Проверяем остальные конструктивы (кроме "подголовник")
                        let otherMechanismMatch = true;
                        const otherMechanismFilters = mechanismFilters.filter(f => !f.includes("подг"));
                        if (otherMechanismFilters.length > 0) {
                            const cleanedUniqueName = uniqueName
                                .replace(/\s*([мm]b|mb)[-\s]?\d*\s*/gi, ' ')
                                .trim()
                                .toLowerCase();
                            otherMechanismMatch = otherMechanismFilters.every(filter => {
                                const patterns = filter.split('|');
                                return patterns.some(pattern => {
                                    const lowerPattern = pattern.toLowerCase().trim();
                                    const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                                    return regex.test(cleanedUniqueName);
                                });
                            });
                        }

                        // Проверяем исполнение (если выбрано)
                        let finishMatch = true;
                        if (finishFilters.length > 0) {
                            const cleanedUniqueName = uniqueName.toLowerCase();
                            finishMatch = finishFilters.every(filter => {
                                const patterns = filter.split('|');
                                return patterns.some(pattern => {
                                    const lowerPattern = pattern.toLowerCase().trim();
                                    if (lowerPattern === 'хром' || lowerPattern === 'ch') {
                                        const regex = /(^|\s)(ch|хром)(\s|$)/i;
                                        return regex.test(cleanedUniqueName);
                                    }
                                    const regex = new RegExp(`(^|\\s)(${lowerPattern})(\\s|$|-)`, 'i');
                                    return regex.test(cleanedUniqueName);
                                });
                            });
                        }

                        // Проверяем нагрузку (если выбрана)
                        let loadMatch = true;
                        if (loadFilters.length > 0) {
                            const maxLoad = product.guarantee?.[0]?.max_load;
                            if (!maxLoad) {
                                loadMatch = false;
                            } else {
                                const standardLoads = ["90", "120", "130", "150", "180", "210"];
                                const isOtherSelected = loadFilters.includes("other");
                                const isStandardLoad = standardLoads.includes(String(maxLoad));

                                if (isOtherSelected && !isStandardLoad) {
                                    loadMatch = true;
                                } else if (!isOtherSelected && isStandardLoad) {
                                    loadMatch = loadFilters.some(load => String(maxLoad) === load);
                                } else {
                                    loadMatch = false;
                                }
                            }
                        }

                        // Проверяем диаметр (если выбран)
                        let diameterMatch = true;
                        if (diameterFilters.length > 0) {
                            const diameter = product.dimensions_details?.[0]?.diameter_cross;
                            const isOtherSelected = diameterFilters.includes("other");

                            // Если диаметр не указан вообще (нет поля или пустое)
                            if (!diameter || (!diameter.min && !diameter.max && typeof diameter !== 'number')) {
                                diameterMatch = isOtherSelected; // Пропускаем только если выбран "other"
                            } else {
                                // Если диаметр указан
                                const diameterValue = typeof diameter === 'object' ? (diameter.max || diameter.min) : diameter;
                                const standardDiameters = ["480", "580", "600", "630", "640", "660", "680", "700", "720", "740", "760"];
                                const isStandardDiameter = standardDiameters.includes(String(diameterValue));

                                if (isOtherSelected && !isStandardDiameter) {
                                    diameterMatch = true;
                                } else if (!isOtherSelected && isStandardDiameter) {
                                    diameterMatch = diameterFilters.some(diam => String(diameterValue) === diam);
                                } else {
                                    diameterMatch = false;
                                }
                            }
                        }



                        return armrestMatch && podgоловnikMatch && otherMechanismMatch && finishMatch && loadMatch && diameterMatch;
                    });
                }


                // Фильтрация по поиску
                if (searchTerms.length > 0) {
                    const hasNotSpecifiedTerm = searchTerms.some(term =>
                        term === '__NOT_SPECIFIED__' ||
                        term === '__NOT_SPECIFIED_W__' ||
                        term === '__NOT_SPECIFIED_W_PLUS__' ||
                        term === '__NOT_SPECIFIED_D__' ||
                        term === '__NOT_SPECIFIED_H__'
                    );

                    console.log('Ищем отсутствующие параметры?', hasNotSpecifiedTerm);
                    console.log('Термы поиска:', searchTerms);

                    if (hasNotSpecifiedTerm) {
                        filtered = validProducts.filter(product => {
                            const dimensions = product.dimensions_details?.[0] || {};
                            const dimensionsObj = product.dimensions?.[0] || {};

                            let isMissing = false;

                            searchTerms.forEach(term => {
                                if (term === '__NOT_SPECIFIED_W__') {
                                    const seatWidth = dimensions.seat_width;
                                    isMissing = isMissing ||
                                        !seatWidth ||
                                        seatWidth === "" ||
                                        seatWidth === null ||
                                        seatWidth === undefined ||
                                        (seatWidth && seatWidth.min === null && seatWidth.max === null) ||
                                        (seatWidth && seatWidth.min === "" && seatWidth.max === "");
                                }
                                if (term === '__NOT_SPECIFIED_W_PLUS__') {
                                    const seatWidthWithArmrests = dimensions.seat_width_with_armrests;
                                    isMissing = isMissing ||
                                        !seatWidthWithArmrests ||
                                        seatWidthWithArmrests === "" ||
                                        seatWidthWithArmrests === null ||
                                        seatWidthWithArmrests === undefined ||
                                        (seatWidthWithArmrests && seatWidthWithArmrests.min === null && seatWidthWithArmrests.max === null) ||
                                        (seatWidthWithArmrests && seatWidthWithArmrests.min === "" && seatWidthWithArmrests.max === "");
                                }
                                if (term === '__NOT_SPECIFIED_D__') {
                                    if (term === '__NOT_SPECIFIED_D__') {
                                        const chairDepth = dimensions.chair_depth;
                                        const seatDepth = dimensions.seat_depth;
                                        isMissing = isMissing ||
                                            !chairDepth ||
                                            chairDepth === "" ||
                                            chairDepth === null ||
                                            chairDepth === undefined ||
                                            (chairDepth && chairDepth.min === null && chairDepth.max === null) ||
                                            (chairDepth && chairDepth.min === "" && chairDepth.max === "") ||
                                            !seatDepth ||
                                            seatDepth === "" ||
                                            seatDepth === null ||
                                            seatDepth === undefined ||
                                            (seatDepth && seatDepth.min === null && seatDepth.max === null) ||
                                            (seatDepth && seatDepth.min === "" && seatDepth.max === "");
                                    }

                                }
                                if (term === '__NOT_SPECIFIED_H__') {
                                    const chairHeight = dimensions.chair_height;
                                    isMissing = isMissing ||
                                        !chairHeight ||
                                        chairHeight === "" ||
                                        chairHeight === null ||
                                        chairHeight === undefined ||
                                        (chairHeight && chairHeight.min === null && chairHeight.max === null) ||
                                        (chairHeight && chairHeight.min === "" && chairHeight.max === "");
                                }
                                if (term === '__NOT_SPECIFIED__') {
                                    isMissing = isMissing ||
                                        !dimensions.chair_height ||
                                        !dimensions.seat_width_with_armrests ||
                                        !dimensions.seat_width ||
                                        !dimensions.chair_depth;
                                }
                            });

                            if (isMissing) {
                                console.log('Найден товар с отсутствующим параметром:', product.unique_name);
                                return true;
                            }
                            return false;
                        });
                    } else {
                        filtered = filtered.filter(product => {
                            return searchTerms.every(term => {
                                // Если терм — число, ищем в числовых полях
                                if (!isNaN(term)) {
                                    const numSearch = parseFloat(term);
                                    const dimensions = product.dimensions_details?.[0] || {};
                                    const checkNumericField = (field) => {
                                        if (!field) return false;
                                        if (typeof field === 'object') {
                                            const min = field.min ? parseFloat(field.min) : null;
                                            const max = field.max ? parseFloat(field.max) : null;
                                            return (min !== null && min === numSearch) || (max !== null && max === numSearch) || (min !== null && max === null && min === numSearch);
                                        }
                                        return parseFloat(field) === numSearch;
                                    };

                                    return (
                                        checkNumericField(dimensions.chair_height) ||
                                        checkNumericField(dimensions.chair_depth) ||
                                        checkNumericField(dimensions.seat_width) ||
                                        checkNumericField(dimensions.seat_width_with_armrests) ||
                                        checkNumericField(dimensions.seat_depth) ||
                                        checkNumericField(dimensions.backrest_height) ||
                                        checkNumericField(dimensions.backrest_to_seat_height) ||
                                        checkNumericField(dimensions.diameter_cross) ||
                                        checkNumericField(dimensions.runners_width) ||
                                        checkNumericField(dimensions.runners_depth) ||
                                        searchInObject(product, term)
                                    );
                                } else {
                                    return searchInObject(product, term);
                                }
                            });
                        });
                    }
                }

                // Фильтрация по высоте
                // if (!(min === minSliderValue && max === maxSliderValue)) {
                //     filtered = filtered.filter(product => {
                //         const chairHeight = product.dimensions_details?.[0]?.chair_height || {};
                //         if (chairHeight && chairHeight.min && chairHeight.max) {
                //             const minHeight = parseInt(chairHeight.min) || 0;
                //             const maxHeight = parseInt(chairHeight.max) || minHeight;
                //             // Оба значения должны быть строго внутри диапазона
                //             return minHeight >= min && maxHeight <= max;
                //         } else if (chairHeight && chairHeight.min && !chairHeight.max) {
                //             // Если указана только минимальная высота
                //             const minHeight = parseInt(chairHeight.min) || 0;
                //             return minHeight >= min && minHeight <= max;
                //         } else if (chairHeight && !chairHeight.min && chairHeight.max) {
                //             // Если указана только максимальная высота
                //             const maxHeight = parseInt(chairHeight.max) || 0;
                //             return maxHeight >= min && maxHeight <= max;
                //         } else {
                //             return false;
                //         }
                //     });
                // }

                // Фильтрация по высоте кресла

                // if (isChairHeightChanged && !(min === minSliderValue && max === maxSliderValue)) {
                //     filtered = filtered.filter(product => {
                //         const chairHeight = product.dimensions_details?.[0]?.chair_height || {};
                //         if (!chairHeight || (!chairHeight.min && !chairHeight.max)) {
                //             return false; // Исключаем товары, у которых высота не указана
                //         }
                //         if (chairHeight) {
                //             const minHeight = chairHeight.min ? parseInt(chairHeight.min) : 0;
                //             const maxHeight = chairHeight.max ? parseInt(chairHeight.max) : null;

                //             if (maxHeight === null || minHeight === null) {
                //                 // Если max не указан, проверяем только min
                //                 return (minHeight >= min && minHeight <= max);
                //             } else {
                //                 // Если оба значения указаны, проверяем, что хотя бы одно попадает в диапазон
                //                 return (minHeight >= min && minHeight <= max) && (maxHeight >= min && maxHeight <= max);
                //             }
                //         } else {
                //             return false;
                //         }
                //     });
                //     console.log("Товары после фильтрации по высоте:", filtered.map(p => p.unique_name));
                // }



                // if (isChairHeightChanged && !(min === minSliderValue && max === maxSliderValue)) {
                //     filtered = filtered.filter(product => {
                //         const chairHeight = product.dimensions_details?.[0]?.chair_height;
                //         if (!chairHeight || (!chairHeight.min && !chairHeight.max)) {
                //             return false; // Исключаем товары, у которых высота не указана
                //         }
                //         const minHeight = chairHeight.min ? parseInt(chairHeight.min) : null;
                //         const maxHeight = chairHeight.max ? parseInt(chairHeight.max) : null;

                //         if (minHeight !== null && maxHeight !== null) {
                //             return (
                //                 minHeight <= max &&
                //                 min <= maxHeight
                //             );
                //         } else if (minHeight !== null) {
                //             return minHeight >= min && minHeight <= max;
                //         } else if (maxHeight !== null) {
                //             return maxHeight >= min && maxHeight <= max;
                //         } else {
                //             return false;
                //         }
                //     });
                //                     console.log("Товары после фильтрации по высоте:", filtered.map(p => p.unique_name));
                //                 }


                // if (isChairHeightChanged && !(min === minSliderValue && max === maxSliderValue)) {
                //     filtered = filtered.filter(product => {
                //         const chairHeight = product.dimensions_details?.[0]?.chair_height || {};
                //         if (!chairHeight || (!chairHeight.min && !chairHeight.max)) {
                //             return false; // Исключаем товары, у которых высота не указана
                //         }
                //         const minHeight = chairHeight.min ? parseInt(chairHeight.min) : null;
                //         const maxHeight = chairHeight.max ? parseInt(chairHeight.max) : null;

                //         // Если указан только min
                //         if (minHeight !== null && maxHeight === null) {
                //             return minHeight >= min && minHeight <= max;
                //         }
                //         // Если указан только max
                //         if (minHeight === null && maxHeight !== null) {
                //             return maxHeight >= min && maxHeight <= max;
                //         }
                //         // Если указаны оба
                //         if (minHeight !== null && maxHeight !== null) {
                //             // Проверяем пересечение диапазонов
                //             return (
                //                 minHeight <= max &&
                //                 min <= maxHeight
                //             );
                //         }
                //         return false;
                //     });
                // }

                if (isChairHeightChanged && !(min === minSliderValue && max === maxSliderValue)) {
                    filtered = filtered.filter(product => {
                        const chairHeight = product.dimensions_details?.[0]?.chair_height || {};
                        if (!chairHeight || (!chairHeight.min && !chairHeight.max)) {
                            return false;
                        }
                        const minHeight = chairHeight.min ? parseInt(chairHeight.min) : null;
                        const maxHeight = chairHeight.max ? parseInt(chairHeight.max) : null;

                        // Если указан только minHeight
                        if (minHeight !== null && maxHeight === null) {
                            return minHeight >= min && minHeight <= max;
                        }
                        // Если указан только maxHeight
                        if (minHeight === null && maxHeight !== null) {
                            return maxHeight >= min && maxHeight <= max;
                        }
                        // Если указаны оба
                        if (minHeight !== null && maxHeight !== null) {
                            // Проверяем пересечение диапазонов
                            return !(
                                maxHeight < min ||
                                minHeight > max
                            );
                        }
                        return false;
                    });
                }


                // 5. Фильтрация по ширине сиденья с подлокотниками
                console.log("Товары до фильтрации по ширине:", filtered.map(p => p.unique_name));

                if (isSeatWidthWithArmrestsChanged && !(minSeatWidthWithArmrests === 100 && maxSeatWidthWithArmrests === 1800)) {
                    filtered = filtered.filter(product => {
                        const dimensions = product.dimensions_details?.[0] || {};
                        const seatWidthWithArmrests = dimensions.seat_width_with_armrests;
                        const diameterCross = dimensions.diameter_cross;
                        const runnersWidth = dimensions.runners_width;



                        // Определяем значение для фильтрации (приоритет: seat_width_with_armrests → diameter_cross → runners_width)
                        let widthValue = null;
                        if (seatWidthWithArmrests?.min || seatWidthWithArmrests?.max) {
                            widthValue = {
                                min: seatWidthWithArmrests.min ? parseInt(seatWidthWithArmrests.min) : null,
                                max: seatWidthWithArmrests.max ? parseInt(seatWidthWithArmrests.max) : null
                            };
                        } else if (diameterCross?.min || diameterCross?.max) {
                            widthValue = {
                                min: diameterCross.min ? parseInt(diameterCross.min) : null,
                                max: diameterCross.max ? parseInt(diameterCross.max) : null
                            };
                        } else if (runnersWidth?.min || runnersWidth?.max) {
                            widthValue = {
                                min: runnersWidth.min ? parseInt(runnersWidth.min) : null,
                                max: runnersWidth.max ? parseInt(runnersWidth.max) : null
                            };
                        }

                        // Если ни одно из полей не заполнено — исключаем товар
                        if (!widthValue) {
                            return false;
                        }

                        // Если значение найдено, проверяем попадание в диапазон
                        if (widthValue) {
                            const minW = widthValue.min || 0;
                            const maxW = widthValue.max || minW;
                            return (minW >= minSeatWidthWithArmrests && minW <= maxSeatWidthWithArmrests) ||
                                (maxW >= minSeatWidthWithArmrests && maxW <= maxSeatWidthWithArmrests);
                        }

                        // Если значение не найдено, пропускаем товар (или оставляем, если нужно)
                        return true;
                    });
                }

                console.log("Товары после фильтрации по ширине сиденья с подлокотниками:", filtered.map(p => p.unique_name));
                const missingProducts = validProducts.filter(p => !filtered.some(fp => fp.unique_name === p.unique_name));
                console.log("Пропущенные товары:", missingProducts);

                // 7. Фильтрация по габаритной глубине
                if (isChairDepthChanged) {
                    const minChairDepth = parseInt(document.getElementById('minChairDepth').value);
                    const maxChairDepth = parseInt(document.getElementById('maxChairDepth').value);
                    filtered = filtered.filter(product => {
                        const chairDepth = product.dimensions_details?.[0]?.chair_depth;
                        if (!chairDepth || (!chairDepth.min && !chairDepth.max)) {
                            return false;
                        }
                        const minD = chairDepth.min ? parseInt(chairDepth.min) : null;
                        const maxD = chairDepth.max ? parseInt(chairDepth.max) : null;
                        if (minD !== null && maxD !== null) {
                            return !(
                                maxD < minChairDepth ||
                                minD > maxChairDepth
                            );
                        } else if (minD !== null) {
                            return minD >= minChairDepth && minD <= maxChairDepth;
                        } else if (maxD !== null) {
                            return maxD >= minChairDepth && maxD <= maxChairDepth;
                        }
                        return false;
                    });
                }

                // 8. Фильтрация по глубине сиденья
                if (isSeatDepthChanged) {
                    const minSeatDepth = parseInt(document.getElementById('minSeatDepth').value);
                    const maxSeatDepth = parseInt(document.getElementById('maxSeatDepth').value);
                    filtered = filtered.filter(product => {
                        const seatDepth = product.dimensions_details?.[0]?.seat_depth;
                        if (!seatDepth || (!seatDepth.min && !seatDepth.max)) {
                            return false;
                        }
                        const minD = seatDepth.min ? parseInt(seatDepth.min) : null;
                        const maxD = seatDepth.max ? parseInt(seatDepth.max) : null;
                        if (minD !== null && maxD !== null) {
                            return !(
                                maxD < minSeatDepth ||
                                minD > maxSeatDepth
                            );
                        } else if (minD !== null) {
                            return minD >= minSeatDepth && minD <= maxSeatDepth;
                        } else if (maxD !== null) {
                            return maxD >= minSeatDepth && maxD <= maxSeatDepth;
                        }
                        return false;
                    });
                }

                // 9. Фильтрация по ширине сиденья
                if (isSeatWidthChanged && !(minSeatWidth === 100 && maxSeatWidth === 1800)) {
                    const minSeatWidth = parseInt(document.getElementById('minSeatWidth').value);
                    const maxSeatWidth = parseInt(document.getElementById('maxSeatWidth').value);
                    filtered = filtered.filter(product => {
                        const seatWidth = product.dimensions_details?.[0]?.seat_width;
                        if (!seatWidth || (!seatWidth.min && !seatWidth.max)) {
                            return false;
                        }
                        const minW = seatWidth.min ? parseInt(seatWidth.min) : null;
                        const maxW = seatWidth.max ? parseInt(seatWidth.max) : null;
                        if (minW !== null && maxW !== null) {
                            return !(
                                maxW < minSeatWidth ||
                                minW > maxSeatWidth
                            );
                        } else if (minW !== null) {
                            return minW >= minSeatWidth && minW <= maxSeatWidth;
                        } else if (maxW !== null) {
                            return maxW >= minSeatWidth && maxW <= maxSeatWidth;
                        }
                        return false;
                    });
                }

                // // 6. Фильтрация по высоте сиденья от пола
                if (isSeatToFloorHeightChanged && !(minSeatToFloorHeight === 100 && maxSeatToFloorHeight === 1800)) {
                    filtered = filtered.filter(product => {
                        const seatToFloorHeight = product.dimensions_details?.[0]?.seat_to_floor_height;
                        // if (!seatToFloorHeight) return true; // Не отсеиваем, если высота не указана
                        if (!seatToFloorHeight || (!seatToFloorHeight.min && !seatToFloorHeight.max)) {
                            return false; // Исключаем товары, у которых высота сиденья не указана
                        }

                        const minH = seatToFloorHeight.min ? parseInt(seatToFloorHeight.min) : null;
                        const maxH = seatToFloorHeight.max ? parseInt(seatToFloorHeight.max) : null;

                        if (minH !== null && maxH !== null) {
                            return (minH >= minSeatToFloorHeight && minH <= maxSeatToFloorHeight) ||
                                (maxH >= minSeatToFloorHeight && maxH <= maxSeatToFloorHeight);
                        } else if (minH !== null) {
                            return minH >= minSeatToFloorHeight && minH <= maxSeatToFloorHeight;
                        } else if (maxH !== null) {
                            return maxH >= minSeatToFloorHeight && maxH <= maxSeatToFloorHeight;
                        } else {
                            return true;
                        }
                    });
                }


                // 6. Фильтрация по высоте сиденья от пола
                // if (isSeatToFloorHeightChanged && !(minSeatToFloorHeight === 100 && maxSeatToFloorHeight === 1800)) {
                //     filtered = filtered.filter(product => {
                //         const seatToFloorHeight = product.dimensions_details?.[0]?.seat_to_floor_height;
                //         if (!seatToFloorHeight || (!seatToFloorHeight.min && !seatToFloorHeight.max)) {
                //             return false; // Исключаем товары, у которых высота сиденья не указана
                //         }

                //         const minH = seatToFloorHeight.min ? parseInt(seatToFloorHeight.min) : null;
                //         const maxH = seatToFloorHeight.max ? parseInt(seatToFloorHeight.max) : null;

                //         // Если оба значения указаны
                //         if (minH !== null && maxH !== null) {
                //             // Проверяем пересечение диапазонов
                //             return (
                //                 minH <= maxSeatToFloorHeight &&
                //                 minSeatToFloorHeight <= maxH
                //             );
                //         }
                //         // Если указано только minH
                //         else if (minH !== null) {
                //             return (
                //                 minH >= minSeatToFloorHeight &&
                //                 minH <= maxSeatToFloorHeight
                //             );
                //         }
                //         // Если указано только maxH
                //         else if (maxH !== null) {
                //             return (
                //                 maxH >= minSeatToFloorHeight &&
                //                 maxH <= maxSeatToFloorHeight
                //             );
                //         }
                //         // Если ничего не указано
                //         else {
                //             return false;
                //         }
                //     });
                // }
                console.log("Товары после фильтрации по высоте сиденья от пола:", filtered.map(p => p.unique_name));


                filteredProducts = filtered;
                document.getElementById('productsCountValue').textContent = filteredProducts.length;
                console.log(`Актуальное количество отфильтрованных товаров: ${filteredProducts.length}`);
                // console.log('Первые 3 товара:', filteredProducts.slice(0, 3));

                buildOverallChart(filteredProducts);

                // Очищаем контейнер и добавляем отфильтрованные товары
                productsContainer.innerHTML = '';
                if (filteredProducts.length === 0) {
                    productsContainer.innerHTML = '<p>Варианты отсутствуют. Измените условия фильтрации</p>';
                    return;
                }

                filteredProducts.forEach(product => {
                    const productName = Array.isArray(product.name) && product.name.length > 0 ? product.name[0] : product.name || 'Без названия';
                    const uniqueName = Array.isArray(product.unique_name) ? product.unique_name[0].trim() : product.unique_name.trim();

                    // Логика для всплывающих подсказок
                    const chairHeight = product.dimensions_details?.[0]?.chair_height;
                    let tooltipText = '<strong>h</strong><br>не указана';
                    if (chairHeight) {
                        const minH = chairHeight?.min ? parseInt(chairHeight.min) : null;
                        const maxH = chairHeight?.max ? parseInt(chairHeight.max) : null;

                        if (minH !== null && maxH !== null) {
                            tooltipText = minH === maxH ? `<strong>h</strong><br>${minH}` : `<strong>h</strong><br>${minH}-${maxH}`;
                        } else if (minH !== null) {
                            tooltipText = `<strong>h</strong><br>${minH}`;
                        } else if (maxH !== null) {
                            tooltipText = `<strong>h</strong><br>${maxH}`;
                        } else {
                            tooltipText = '<strong>h</strong><br>не указана';
                        }
                    }

                    // Логика для ширины с подлокотниками
                    const chairWidth = product.dimensions_details?.[0]?.seat_width_with_armrests;
                    let tooltipTextWidth = '';
                    if (chairWidth) {
                        const minW = chairWidth.min || null;
                        const maxW = chairWidth.max || null;
                        if (minW && maxW) {
                            tooltipTextWidth = minW === maxW ? `<strong>w+</strong><br>${minW}` : `<strong>w+</strong><br>${minW}-${maxW}`;
                        } else if (minW) {
                            tooltipTextWidth = `<strong>w+</strong><br>${minW}`;
                        } else if (maxW) {
                            tooltipTextWidth = `<strong>w+</strong><br>${maxW}`;
                        }
                    }

                    // Логика для ширины сиденья
                    const chairWidthSit = product.dimensions_details?.[0]?.seat_width;
                    let tooltipTextWidthSit = '<strong>w</strong><br>не указана';
                    if (chairWidthSit) {
                        const minW = chairWidthSit.min || null;
                        const maxW = chairWidthSit.max || null;
                        if (minW && maxW) {
                            tooltipTextWidthSit = minW === maxW ? `<strong>w</strong><br>${minW}` : `<strong>w</strong><br>${minW}-${maxW}`;
                        } else if (minW) {
                            tooltipTextWidthSit = `<strong>w</strong><br>${minW}`;
                        } else if (maxW) {
                            tooltipTextWidthSit = `<strong>w</strong><br>${maxW}`;
                        }
                    }

                    // Логика для глубины
                    const chairDepth = product.dimensions_details?.[0]?.chair_depth;
                    let tooltipTextDepth = '<strong>d</strong><br>не указана';
                    if (chairDepth) {
                        const minD = chairDepth.min || null;
                        const maxD = chairDepth.max || null;
                        if (minD && maxD) {
                            tooltipTextDepth = minD === maxD ? `<strong>d</strong><br>${minD}` : `<strong>d</strong><br>${minD}-${maxD}`;
                        } else if (minD) {
                            tooltipTextDepth = `<strong>d</strong><br>${minD}`;
                        } else if (maxD) {
                            tooltipTextDepth = `<strong>d</strong><br>${maxD}`;
                        }
                    }

                    // Детальная всплывающая подсказка
                    const headrestHeight = product.dimensions_details?.[0]?.headrest_height;
                    const seatToFloorHeight = product.dimensions_details?.[0]?.seat_to_floor_height;
                    const armrestHeightFromSeat = product.dimensions_details?.[0]?.armrest_height_from_seat;
                    const seatDepth = product.dimensions_details?.[0]?.seat_depth;
                    const backrestHeight = product.dimensions_details?.[0]?.backrest_height;
                    const backrestToSeatHeight = product.dimensions_details?.[0]?.height_backrest_seat;
                    const seatWidth = product.dimensions_details?.[0]?.seat_width;
                    const diameterCross = product.dimensions_details?.[0]?.diameter_cross;
                    const runnersWidth = product.dimensions_details?.[0]?.runners_width;
                    const runnersDepth = product.dimensions_details?.[0]?.runners_depth;
                    const maxLoad = product.guarantee?.[0]?.max_load;
                    const boxSize = product.transportation?.[0]?.packaging?.box_size;
                    const brutto = product.dimensions?.[0]?.brutto;
                    const netto = product.dimensions?.[0]?.netto;
                    const volume = product.dimensions?.[0]?.volume;
                    const upholstery = product.construction_and_materials?.[0]?.upholstery_materials?.[0];

                    // Получаем данные по упаковкам
                    const packagingData = product.dimensions?.[0]?.packaging_type || [];
                    let bruttoIndividual = null, nettoIndividual = null, volumeIndividual = null;
                    let bruttoBox4 = null, nettoBox4 = null, volumeBox4 = null;

                    packagingData.forEach(pack => {
                        if (pack.type === 'individual') {
                            bruttoIndividual = pack.brutto;
                            nettoIndividual = pack.netto;
                            volumeIndividual = pack.volume;
                        } else if (pack.type === 'box4') {
                            bruttoBox4 = pack.brutto;
                            nettoBox4 = pack.netto;
                            volumeBox4 = pack.volume;
                        }
                    });

                    // Формируем текст для детальной всплывающей подсказки
                    let detailedTooltipText = `
                        <strong>${productName}</strong><br><br>
                        ${upholstery ? `<strong>Обсуждается дополнительно:<br></strong> ${upholstery.replace('-', '').trim()}<br>` : ''}
${chairHeight?.min || chairHeight?.max ? (() => {
                            const minH = chairHeight.min ? parseInt(chairHeight.min) : null;
                            const maxH = chairHeight.max ? parseInt(chairHeight.max) : null;
                            if (minH && maxH && minH === maxH) {
                                return `<br><strong>Высота кресла:</strong> ${minH} мм<br>`;
                            } else {
                                return `<br><strong>Высота кресла:</strong> ${minH || ''}${minH && maxH ? ' - ' : ''}${maxH || ''} мм<br>`;
                            }
                        })() : ''}
                        ${headrestHeight?.min || headrestHeight?.max ? `<strong>Высота с подголовником:</strong> ${headrestHeight.min || ''}${headrestHeight.min && headrestHeight.max ? ' - ' : ''}${headrestHeight.max || ''} мм<br>` : ''}
                        ${seatToFloorHeight?.min || seatToFloorHeight?.max ? `<strong>Высота сиденья от пола:</strong> ${seatToFloorHeight.min || ''}${seatToFloorHeight.min && seatToFloorHeight.max ? ' - ' : ''}${seatToFloorHeight.max || ''} мм<br>` : ''}
                        ${armrestHeightFromSeat?.min || armrestHeightFromSeat?.max ? `<strong>Высота подлокотников от сиденья:</strong> ${armrestHeightFromSeat.min || ''}${armrestHeightFromSeat.min && armrestHeightFromSeat.max ? ' - ' : ''}${armrestHeightFromSeat.max || ''} мм<br>` : ''}
                        ${chairDepth?.min || chairDepth?.max ? `<strong>Глубина кресла:</strong> ${chairDepth.min || ''}${chairDepth.min && chairDepth.max ? ' - ' : ''}${chairDepth.max || ''} мм<br>` : ''}
                        ${seatDepth?.min || seatDepth?.max ? `<strong>Глубина сиденья:</strong> ${seatDepth.min || ''}${seatDepth.min && seatDepth.max ? ' - ' : ''}${seatDepth.max || ''} мм<br>` : ''}
                        ${backrestHeight?.min || backrestHeight?.max ? `<strong>Высота спинки:</strong> ${backrestHeight.min || ''}${backrestHeight.min && backrestHeight.max ? ' - ' : ''}${backrestHeight.max || ''} мм<br>` : ''}
                        ${backrestToSeatHeight?.min || backrestToSeatHeight?.max ? `<strong>Высота спинки от сиденья:</strong> ${backrestToSeatHeight.min || ''}${backrestToSeatHeight.min && backrestToSeatHeight.max ? ' - ' : ''}${backrestToSeatHeight.max || ''} мм<br>` : ''}
                        ${chairWidth?.min || chairWidth?.max ? `<strong>Ширина сиденья с подлокотниками:</strong> ${chairWidth.min || ''}${chairWidth.min && chairWidth.max ? ' - ' : ''}${chairWidth.max || ''} мм<br>` : ''}
                        ${seatWidth?.min || seatWidth?.max ? `<strong>Ширина сиденья:</strong> ${seatWidth.min || ''}${seatWidth.min && seatWidth.max ? ' - ' : ''}${seatWidth.max || ''} мм<br>` : ''}
                        ${diameterCross?.min || diameterCross?.max ? `<strong>Диаметр крестовины:</strong> ${diameterCross.min || ''}${diameterCross.min && diameterCross.max ? ' - ' : ''}${diameterCross.max || ''} мм<br>` : ''}
                        ${runnersWidth?.min || runnersWidth?.max ? `<strong>Ширина полозьев/ножек:</strong> ${runnersWidth.min || ''}${runnersWidth.min && runnersWidth.max ? ' - ' : ''}${runnersWidth.max || ''} мм<br>` : ''}
                        ${runnersDepth?.min || runnersDepth?.max ? `<strong>Глубина полозьев/ножек:</strong> ${runnersDepth.min || ''}${runnersDepth.min && runnersDepth.max ? ' - ' : ''}${runnersDepth.max || ''} мм<br>` : ''}
                        ${boxSize ? `<strong>Размер коробки:</strong> ${boxSize}<br>` : ''}
                    `;

                    // Если есть packaging_type, добавляем данные по упаковкам
                    if (packagingData.length > 0) {
                        detailedTooltipText += `
                            ${bruttoIndividual ? `<strong>Вес брутто (индивидуальная):</strong> ${bruttoIndividual} кг<br>` : ''}
                            ${nettoIndividual ? `<strong>Вес нетто (индивидуальная):</strong> ${nettoIndividual} кг<br>` : ''}
                            ${volumeIndividual ? `<strong>Объем (индивидуальная):</strong> ${volumeIndividual} м³<br>` : ''}
                            ${bruttoBox4 ? `<strong>Вес брутто (BOX4):</strong> ${bruttoBox4} кг<br>` : ''}
                            ${nettoBox4 ? `<strong>Вес нетто (BOX4):</strong> ${nettoBox4} кг<br>` : ''}
                            ${volumeBox4 ? `<strong>Объем (BOX4):</strong> ${volumeBox4} м³<br>` : ''}
                        `;
                    } else {
                        // Если нет packaging_type, используем старые данные
                        detailedTooltipText += `
                            ${brutto ? `<strong>Вес брутто:</strong> ${brutto} кг<br>` : ''}
                            ${netto ? `<strong>Вес нетто:</strong> ${netto} кг<br>` : ''}
                            ${volume ? `<strong>Объем:</strong> ${volume} м³<br>` : ''}
                        `;
                    }

                    detailedTooltipText += `
                        ${maxLoad ? `<strong>Макс. нагрузка:</strong> ${maxLoad} кг<br>` : ''}
                    `;


                    const productCard = document.createElement('div');
                    productCard.className = 'product-card';


                    productCard.innerHTML = `
                        <div class="product-tooltip">${tooltipTextWidth}<br>${tooltipTextWidthSit}<br>${tooltipTextDepth}<br>${tooltipText}</div>
                        <div class="product-tooltip-detailed">${detailedTooltipText}</div>
                        <img src="${product.images?.[0]?.vid_main || ''}" alt="${uniqueName}">
                        <button class="open-card-modal" data-category="${product.category}" data-name="${productName}" data-unique-name="${uniqueName}">
                            ${uniqueName}
                        </button>
                    `;
                    // Добавляем красный кружок, если clean: true
                    if (product.lost?.[0]?.clean === true) {
                        const lostIndicator = document.createElement('div');
                        lostIndicator.className = 'lost-indicator';
                        productCard.appendChild(lostIndicator);
                        console.log("Добавлен lostIndicator", product)
                    }
                    // Добавляем салатовый кружок, если limit: true
                    if (product.lost?.[0]?.limit === true) {
                        const limitIndicator = document.createElement('div');
                        limitIndicator.className = 'limit-indicator';
                        productCard.appendChild(limitIndicator);
                    }
                    productsContainer.appendChild(productCard);


                    // Обработчики событий для каждой карточки
                    productCard.addEventListener('mouseenter', function () {
                        const imgElement = this.querySelector('img');
                        const detailedTooltip = this.querySelector('.product-tooltip-detailed');
                        const chairViewUrl = product.images?.[0]?.chair_view;
                        if (chairViewUrl && imgElement) {
                            imgElement.src = chairViewUrl;
                        }
                    });

                    productCard.addEventListener('mouseleave', function () {
                        const imgElement = this.querySelector('img');
                        const detailedTooltip = this.querySelector('.product-tooltip-detailed');
                        const vidMainUrl = product.images?.[0]?.vid_main;
                        if (vidMainUrl && imgElement) {
                            imgElement.src = vidMainUrl;
                        }
                    });
                });

                    recalculateSliderValues(filteredProducts);

                
                // Добавляем обработчики для кнопок открытия PDF в новом окне
                document.querySelectorAll('.open-card-modal').forEach(button => {
                    button.addEventListener('click', function () {
                        const category = this.getAttribute('data-category');
                        const name = this.getAttribute('data-name');
                        let uniqueName = this.getAttribute('data-unique-name');
                        // Приводим к виду: первая буква заглавная, остальные строчные
                        uniqueName = uniqueName.charAt(0).toUpperCase() + uniqueName.slice(1).toLowerCase();
                        const url = `card.html?category=${encodeURIComponent(category)}&name=${encodeURIComponent(name)}&unique_name=${encodeURIComponent(uniqueName)}`;
                        window.open(url, '_blank');
                    });


                });
            }
            document.querySelectorAll('.category-filter').forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    // Пересчитываем минимальные и максимальные значения для ползунков
                    recalculateSliderValues();
                    // Фильтруем товары
                    filterProducts();
                });

                document.querySelectorAll('.special-offer-filter').forEach(checkbox => {
                    checkbox.addEventListener('change', () => {
                        recalculateSliderValues();
                        filterProducts();
                    });
                });


            });
            // Функция нормализации поискового запроса
            function normalizeSearchTerm(term) {
                // Если term — undefined или null, возвращаем "__NOT_SPECIFIED__"
                if (term == null) return '__NOT_SPECIFIED__';

                // Приводим к строке (на случай, если пришло число или другой тип)
                term = String(term).toLowerCase().trim();

                // Замены для конкретных терминов
                term = term
                    .replace(/люкс|lux|LUX|Lyuks|Lyux|Liuks|Liux|люкc|ЛЮКС/gi, 'люкс')
                    .replace(/полозья|Н_п|Нп|полоз/gi, 'полозья')
                    .replace(/велюр|велютто|velu|velur/gi, 'велюр')
                    .replace(/модерно|mod|moderno|модерн/gi, 'модерно')
                    .replace(/мультиб|мультиблок|МВ|MB/gi, 'мультиблок');



                // Проверяем на параметры с "не указана"
                if (term.includes('высота не указана') || term.includes('h не указана')) {
                    return '__NOT_SPECIFIED_H__';
                }
                if (term.includes('ширина не указана') || term.includes('w не указана')) {
                    return '__NOT_SPECIFIED_W__';
                }
                if (term.includes('ширина с подлокотниками не указана') || term.includes('w+ не указана')) {
                    return '__NOT_SPECIFIED_W_PLUS__';
                }
                if (term.includes('глубина не указана') || term.includes('d не указана')) {
                    return '__NOT_SPECIFIED_D__';
                }

                // Остальные замены
                if (term === 'не указана' || term === 'не указано' || term === 'не указан') {
                    return '__NOT_SPECIFIED__';
                }

                return term;
            }






            // Функция для построения диаграммы
            function buildOverallChart(products) {
                const productNames = products.map(p => p.unique_name[0]);
                const traces = [];
                const parameters = [
                    { name: 'Высота кресла (мм)', key: 'chair_height' },
                    { name: 'Высота подголовника (мм)', key: 'headrest_height' },
                    { name: 'Высота сиденья от пола (мм)', key: 'seat_to_floor_height' },
                    { name: 'Высота подлокотников от сиденья (мм)', key: 'armrest_height_from_seat' },
                    { name: 'Глубина кресла (мм)', key: 'chair_depth' },
                    { name: 'Глубина сиденья (мм)', key: 'seat_depth' },
                    { name: 'Высота спинки (мм)', key: 'backrest_height' },
                    { name: 'Высота спинки от сиденья (мм)', key: 'backrest_to_seat_height' },
                    { name: 'Ширина сиденья с подлокотниками (мм)', key: 'seat_width_with_armrests' },
                    { name: 'Ширина сиденья (мм)', key: 'seat_width' },
                    { name: 'Диаметр крестовины (мм)', key: 'diameter_cross' },
                    { name: 'Ширина полозьев/ножек (мм)', key: 'runners_width' },
                    { name: 'Глубина полозьев/ножек (мм)', key: 'runners_depth' },
                    { name: 'Макс. нагрузка (кг)', key: 'max_load', source: 'guarantee' },
                    { name: 'Рекоменд. нагрузка (кг)', key: 'recommended_load', source: 'guarantee' },
                    { name: 'Вес брутто (кг)', key: 'brutto', source: 'dimensions' },
                    { name: 'Вес нетто (кг)', key: 'netto', source: 'dimensions' },
                    { name: 'Объем (м³)', key: 'volume', source: 'dimensions' }

                ];

                parameters.forEach(param => {
                    const data = products.map(p => {
                        // Для веса и объёма сначала ищем в packaging (индивидуальная упаковка)
                        if (['brutto', 'netto', 'volume'].includes(param.key)) {
                            const packs = p.dimensions?.[0]?.packaging_type || [];
                            const indivPacks = packs.filter(pk => pk.type === 'individual');
                            if (indivPacks.length > 0) {
                                const value = parseNumber(indivPacks[0][param.key]);
                                if (value !== null) return value;
                            }
                            // Если нет в индивидуальной упаковке, ищем в dimensions
                            const dimValue = p.dimensions?.[0]?.[param.key];
                            return parseNumber(dimValue);
                        }
                        // Для остальных параметров - стандартная логика
                        if (param.source === 'packaging') {
                            const packs = p.dimensions?.[0]?.packaging_type || [];
                            const filteredPacks = packs.filter(pk => pk.type === param.type);
                            if (filteredPacks.length > 0) {
                                const values = filteredPacks.map(pk => parseNumber(pk[param.key])).filter(v => v !== null);
                                return values.length > 0 ? Math.max(...values) : null;
                            }
                        }
                        // Если не нашли в packaging, ищем в dimensions
                        if (param.source === 'dimensions' || !param.source) {
                            let value;
                            if (param.source === 'guarantee') {
                                value = p.guarantee?.[0]?.[param.key];
                            } else {
                                value = p.dimensions?.[0]?.[param.key];
                                if (value === undefined) {
                                    const minValue = parseNumber(p.dimensions_details?.[0]?.[param.key]?.min);
                                    const maxValue = parseNumber(p.dimensions_details?.[0]?.[param.key]?.max);
                                    if (minValue !== null && maxValue !== null) {
                                        value = Math.max(minValue, maxValue);
                                    } else if (minValue !== null) {
                                        value = minValue;
                                    } else if (maxValue !== null) {
                                        value = maxValue;
                                    }
                                }
                            }
                            return parseNumber(value);
                        }
                        return null;
                    });
                    if (data.some(val => val !== null)) {
                        traces.push({
                            x: productNames,
                            y: data,
                            name: param.name,
                            type: 'scatter',
                            mode: 'lines+markers'
                        });
                    }
                });

                const layout = {
                    title: { text: '', font: { family: 'Montserrat, sans-serif', size: 14 } },
                    yaxis: { title: { text: '', font: { family: 'Montserrat, sans-serif', size: 11 } }, tickfont: { family: 'Montserrat, sans-serif', size: 11 }, automargin: true },
                    xaxis: { title: { text: '', font: { family: 'Montserrat, sans-serif', size: 11 } }, tickfont: { family: 'Montserrat, sans-serif', size: 11 }, tickangle: -45, automargin: true },
                    legend: { font: { family: 'Montserrat, sans-serif', size: 11 } },
                    showlegend: true,
                    hovermode: 'closest',
                    hoverlabel: { font: { family: 'Montserrat, sans-serif', size: 11 } },
                    margin: { l: 60, r: 20, b: 100, t: 60, pad: 4, autoexpand: true },
                    autosize: true
                };

                Plotly.newPlot('overallChart', traces, layout, { responsive: true });
            }

        });
        // Обработчик возврата назад
        window.addEventListener('pageshow', function (event) {
            document.getElementById('searchInput').value = '';
            document.querySelectorAll('.armrest-filter, .mechanism-filter, .finish-filter, .load-filter, .diameter-filter').forEach(checkbox => {
                checkbox.checked = false;
            });
            const minHeightInput = document.getElementById('minHeight');
            const maxHeightInput = document.getElementById('maxHeight');
            const minHeightValue = document.getElementById('minHeightValue');
            const maxHeightValue = document.getElementById('maxHeightValue');

            if (minHeightInput && maxHeightInput && minHeightValue && maxHeightValue) {
                minHeightInput.value = minHeightInput.min;
                maxHeightInput.value = maxHeightInput.max;
                minHeightValue.value = minHeightInput.min;
                maxHeightValue.value = maxHeightInput.max;

                // Сброс ползунков и числовых полей для ширины сиденья с подлокотниками
                const minSeatWidthWithArmrestsInput = document.getElementById('minSeatWidthWithArmrests');
                const maxSeatWidthWithArmrestsInput = document.getElementById('maxSeatWidthWithArmrests');
                const minSeatWidthWithArmrestsValue = document.getElementById('minSeatWidthWithArmrestsValue');
                const maxSeatWidthWithArmrestsValue = document.getElementById('maxSeatWidthWithArmrestsValue');
                if (minSeatWidthWithArmrestsInput && maxSeatWidthWithArmrestsInput && minSeatWidthWithArmrestsValue && maxSeatWidthWithArmrestsValue) {
                    minSeatWidthWithArmrestsInput.value = minSeatWidthWithArmrestsInput.min;
                    maxSeatWidthWithArmrestsInput.value = maxSeatWidthWithArmrestsInput.max;
                    minSeatWidthWithArmrestsValue.value = minSeatWidthWithArmrestsInput.min;
                    maxSeatWidthWithArmrestsValue.value = maxSeatWidthWithArmrestsInput.max;
                }

                // Сброс ползунков и числовых полей для высоты сиденья от пола
                const minSeatToFloorHeightInput = document.getElementById('minSeatToFloorHeight');
                const maxSeatToFloorHeightInput = document.getElementById('maxSeatToFloorHeight');
                const minSeatToFloorHeightValue = document.getElementById('minSeatToFloorHeightValue');
                const maxSeatToFloorHeightValue = document.getElementById('maxSeatToFloorHeightValue');
                if (minSeatToFloorHeightInput && maxSeatToFloorHeightInput && minSeatToFloorHeightValue && maxSeatToFloorHeightValue) {
                    minSeatToFloorHeightInput.value = minSeatToFloorHeightInput.min;
                    maxSeatToFloorHeightInput.value = maxSeatToFloorHeightInput.max;
                    minSeatToFloorHeightValue.value = minSeatToFloorHeightInput.min;
                    maxSeatToFloorHeightValue.value = maxSeatToFloorHeightInput.max;
                }

                const minChairDepthInput = document.getElementById('minChairDepth');
                const maxChairDepthInput = document.getElementById('maxChairDepth');
                const minChairDepthValue = document.getElementById('minChairDepthValue');
                const maxChairDepthValue = document.getElementById('maxChairDepthValue');
                if (minChairDepthInput && maxChairDepthInput && minChairDepthValue && maxChairDepthValue) {
                    minChairDepthInput.value = minChairDepthInput.min;
                    maxChairDepthInput.value = maxChairDepthInput.max;
                    minChairDepthValue.value = minChairDepthInput.min;
                    maxChairDepthValue.value = maxChairDepthInput.max;
                }

                const minSeatDepthInput = document.getElementById('minSeatDepth');
                const maxSeatDepthInput = document.getElementById('maxSeatDepth');
                const minSeatDepthValue = document.getElementById('minSeatDepthValue');
                const maxSeatDepthValue = document.getElementById('maxSeatDepthValue');
                if (minSeatDepthInput && maxSeatDepthInput && minSeatDepthValue && maxSeatDepthValue) {
                    minSeatDepthInput.value = minSeatDepthInput.min;
                    maxSeatDepthInput.value = maxSeatDepthInput.max;
                    minSeatDepthValue.value = minSeatDepthInput.min;
                    maxSeatDepthValue.value = maxSeatDepthInput.max;
                }

                const minSeatWidthInput = document.getElementById('minSeatWidth');
                const maxSeatWidthInput = document.getElementById('maxSeatWidth');
                const minSeatWidthValue = document.getElementById('minSeatWidthValue');
                const maxSeatWidthValue = document.getElementById('maxSeatWidthValue');
                if (minSeatWidthInput && maxSeatWidthInput && minSeatWidthValue && maxSeatWidthValue) {
                    minSeatWidthInput.value = minSeatWidthInput.min;
                    maxSeatWidthInput.value = maxSeatWidthInput.max;
                    minSeatWidthValue.value = minSeatWidthInput.min;
                    maxSeatWidthValue.value = maxSeatWidthInput.max;
                }

            } else {
                console.error("Один или несколько элементов не найдены!");
                return;
            }


        });

    </script>
</body>

</html>